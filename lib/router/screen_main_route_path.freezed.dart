// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'screen_main_route_path.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$GlobalRoutePathTearOff {
  const _$GlobalRoutePathTearOff();

// ignore: unused_element
  PathDataIntro intro() {
    return const PathDataIntro();
  }

// ignore: unused_element
  PathDataError error() {
    return const PathDataError();
  }

// ignore: unused_element
  PathDataChannel channel(String channelId) {
    return PathDataChannel(
      channelId,
    );
  }

// ignore: unused_element
  PathDataProgram program(String programId) {
    return PathDataProgram(
      programId,
    );
  }

// ignore: unused_element
  PathDataUserLocation editUserLocation(UserLocation userLocation) {
    return PathDataUserLocation(
      userLocation,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $GlobalRoutePath = _$GlobalRoutePathTearOff();

/// @nodoc
mixin _$GlobalRoutePath {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult intro(),
    @required TResult error(),
    @required TResult channel(String channelId),
    @required TResult program(String programId),
    @required TResult editUserLocation(UserLocation userLocation),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult intro(),
    TResult error(),
    TResult channel(String channelId),
    TResult program(String programId),
    TResult editUserLocation(UserLocation userLocation),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult intro(PathDataIntro value),
    @required TResult error(PathDataError value),
    @required TResult channel(PathDataChannel value),
    @required TResult program(PathDataProgram value),
    @required TResult editUserLocation(PathDataUserLocation value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult intro(PathDataIntro value),
    TResult error(PathDataError value),
    TResult channel(PathDataChannel value),
    TResult program(PathDataProgram value),
    TResult editUserLocation(PathDataUserLocation value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $GlobalRoutePathCopyWith<$Res> {
  factory $GlobalRoutePathCopyWith(
          GlobalRoutePath value, $Res Function(GlobalRoutePath) then) =
      _$GlobalRoutePathCopyWithImpl<$Res>;
}

/// @nodoc
class _$GlobalRoutePathCopyWithImpl<$Res>
    implements $GlobalRoutePathCopyWith<$Res> {
  _$GlobalRoutePathCopyWithImpl(this._value, this._then);

  final GlobalRoutePath _value;
  // ignore: unused_field
  final $Res Function(GlobalRoutePath) _then;
}

/// @nodoc
abstract class $PathDataIntroCopyWith<$Res> {
  factory $PathDataIntroCopyWith(
          PathDataIntro value, $Res Function(PathDataIntro) then) =
      _$PathDataIntroCopyWithImpl<$Res>;
}

/// @nodoc
class _$PathDataIntroCopyWithImpl<$Res>
    extends _$GlobalRoutePathCopyWithImpl<$Res>
    implements $PathDataIntroCopyWith<$Res> {
  _$PathDataIntroCopyWithImpl(
      PathDataIntro _value, $Res Function(PathDataIntro) _then)
      : super(_value, (v) => _then(v as PathDataIntro));

  @override
  PathDataIntro get _value => super._value as PathDataIntro;
}

/// @nodoc
class _$PathDataIntro implements PathDataIntro {
  const _$PathDataIntro();

  @override
  String toString() {
    return 'GlobalRoutePath.intro()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PathDataIntro);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult intro(),
    @required TResult error(),
    @required TResult channel(String channelId),
    @required TResult program(String programId),
    @required TResult editUserLocation(UserLocation userLocation),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return intro();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult intro(),
    TResult error(),
    TResult channel(String channelId),
    TResult program(String programId),
    TResult editUserLocation(UserLocation userLocation),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (intro != null) {
      return intro();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult intro(PathDataIntro value),
    @required TResult error(PathDataError value),
    @required TResult channel(PathDataChannel value),
    @required TResult program(PathDataProgram value),
    @required TResult editUserLocation(PathDataUserLocation value),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return intro(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult intro(PathDataIntro value),
    TResult error(PathDataError value),
    TResult channel(PathDataChannel value),
    TResult program(PathDataProgram value),
    TResult editUserLocation(PathDataUserLocation value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (intro != null) {
      return intro(this);
    }
    return orElse();
  }
}

abstract class PathDataIntro implements GlobalRoutePath {
  const factory PathDataIntro() = _$PathDataIntro;
}

/// @nodoc
abstract class $PathDataErrorCopyWith<$Res> {
  factory $PathDataErrorCopyWith(
          PathDataError value, $Res Function(PathDataError) then) =
      _$PathDataErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$PathDataErrorCopyWithImpl<$Res>
    extends _$GlobalRoutePathCopyWithImpl<$Res>
    implements $PathDataErrorCopyWith<$Res> {
  _$PathDataErrorCopyWithImpl(
      PathDataError _value, $Res Function(PathDataError) _then)
      : super(_value, (v) => _then(v as PathDataError));

  @override
  PathDataError get _value => super._value as PathDataError;
}

/// @nodoc
class _$PathDataError implements PathDataError {
  const _$PathDataError();

  @override
  String toString() {
    return 'GlobalRoutePath.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PathDataError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult intro(),
    @required TResult error(),
    @required TResult channel(String channelId),
    @required TResult program(String programId),
    @required TResult editUserLocation(UserLocation userLocation),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return error();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult intro(),
    TResult error(),
    TResult channel(String channelId),
    TResult program(String programId),
    TResult editUserLocation(UserLocation userLocation),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult intro(PathDataIntro value),
    @required TResult error(PathDataError value),
    @required TResult channel(PathDataChannel value),
    @required TResult program(PathDataProgram value),
    @required TResult editUserLocation(PathDataUserLocation value),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult intro(PathDataIntro value),
    TResult error(PathDataError value),
    TResult channel(PathDataChannel value),
    TResult program(PathDataProgram value),
    TResult editUserLocation(PathDataUserLocation value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PathDataError implements GlobalRoutePath {
  const factory PathDataError() = _$PathDataError;
}

/// @nodoc
abstract class $PathDataChannelCopyWith<$Res> {
  factory $PathDataChannelCopyWith(
          PathDataChannel value, $Res Function(PathDataChannel) then) =
      _$PathDataChannelCopyWithImpl<$Res>;
  $Res call({String channelId});
}

/// @nodoc
class _$PathDataChannelCopyWithImpl<$Res>
    extends _$GlobalRoutePathCopyWithImpl<$Res>
    implements $PathDataChannelCopyWith<$Res> {
  _$PathDataChannelCopyWithImpl(
      PathDataChannel _value, $Res Function(PathDataChannel) _then)
      : super(_value, (v) => _then(v as PathDataChannel));

  @override
  PathDataChannel get _value => super._value as PathDataChannel;

  @override
  $Res call({
    Object channelId = freezed,
  }) {
    return _then(PathDataChannel(
      channelId == freezed ? _value.channelId : channelId as String,
    ));
  }
}

/// @nodoc
class _$PathDataChannel implements PathDataChannel {
  const _$PathDataChannel(this.channelId) : assert(channelId != null);

  @override
  final String channelId;

  @override
  String toString() {
    return 'GlobalRoutePath.channel(channelId: $channelId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PathDataChannel &&
            (identical(other.channelId, channelId) ||
                const DeepCollectionEquality()
                    .equals(other.channelId, channelId)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(channelId);

  @override
  $PathDataChannelCopyWith<PathDataChannel> get copyWith =>
      _$PathDataChannelCopyWithImpl<PathDataChannel>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult intro(),
    @required TResult error(),
    @required TResult channel(String channelId),
    @required TResult program(String programId),
    @required TResult editUserLocation(UserLocation userLocation),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return channel(channelId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult intro(),
    TResult error(),
    TResult channel(String channelId),
    TResult program(String programId),
    TResult editUserLocation(UserLocation userLocation),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (channel != null) {
      return channel(channelId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult intro(PathDataIntro value),
    @required TResult error(PathDataError value),
    @required TResult channel(PathDataChannel value),
    @required TResult program(PathDataProgram value),
    @required TResult editUserLocation(PathDataUserLocation value),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return channel(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult intro(PathDataIntro value),
    TResult error(PathDataError value),
    TResult channel(PathDataChannel value),
    TResult program(PathDataProgram value),
    TResult editUserLocation(PathDataUserLocation value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (channel != null) {
      return channel(this);
    }
    return orElse();
  }
}

abstract class PathDataChannel implements GlobalRoutePath {
  const factory PathDataChannel(String channelId) = _$PathDataChannel;

  String get channelId;
  $PathDataChannelCopyWith<PathDataChannel> get copyWith;
}

/// @nodoc
abstract class $PathDataProgramCopyWith<$Res> {
  factory $PathDataProgramCopyWith(
          PathDataProgram value, $Res Function(PathDataProgram) then) =
      _$PathDataProgramCopyWithImpl<$Res>;
  $Res call({String programId});
}

/// @nodoc
class _$PathDataProgramCopyWithImpl<$Res>
    extends _$GlobalRoutePathCopyWithImpl<$Res>
    implements $PathDataProgramCopyWith<$Res> {
  _$PathDataProgramCopyWithImpl(
      PathDataProgram _value, $Res Function(PathDataProgram) _then)
      : super(_value, (v) => _then(v as PathDataProgram));

  @override
  PathDataProgram get _value => super._value as PathDataProgram;

  @override
  $Res call({
    Object programId = freezed,
  }) {
    return _then(PathDataProgram(
      programId == freezed ? _value.programId : programId as String,
    ));
  }
}

/// @nodoc
class _$PathDataProgram implements PathDataProgram {
  const _$PathDataProgram(this.programId) : assert(programId != null);

  @override
  final String programId;

  @override
  String toString() {
    return 'GlobalRoutePath.program(programId: $programId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PathDataProgram &&
            (identical(other.programId, programId) ||
                const DeepCollectionEquality()
                    .equals(other.programId, programId)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(programId);

  @override
  $PathDataProgramCopyWith<PathDataProgram> get copyWith =>
      _$PathDataProgramCopyWithImpl<PathDataProgram>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult intro(),
    @required TResult error(),
    @required TResult channel(String channelId),
    @required TResult program(String programId),
    @required TResult editUserLocation(UserLocation userLocation),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return program(programId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult intro(),
    TResult error(),
    TResult channel(String channelId),
    TResult program(String programId),
    TResult editUserLocation(UserLocation userLocation),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (program != null) {
      return program(programId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult intro(PathDataIntro value),
    @required TResult error(PathDataError value),
    @required TResult channel(PathDataChannel value),
    @required TResult program(PathDataProgram value),
    @required TResult editUserLocation(PathDataUserLocation value),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return program(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult intro(PathDataIntro value),
    TResult error(PathDataError value),
    TResult channel(PathDataChannel value),
    TResult program(PathDataProgram value),
    TResult editUserLocation(PathDataUserLocation value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (program != null) {
      return program(this);
    }
    return orElse();
  }
}

abstract class PathDataProgram implements GlobalRoutePath {
  const factory PathDataProgram(String programId) = _$PathDataProgram;

  String get programId;
  $PathDataProgramCopyWith<PathDataProgram> get copyWith;
}

/// @nodoc
abstract class $PathDataUserLocationCopyWith<$Res> {
  factory $PathDataUserLocationCopyWith(PathDataUserLocation value,
          $Res Function(PathDataUserLocation) then) =
      _$PathDataUserLocationCopyWithImpl<$Res>;
  $Res call({UserLocation userLocation});
}

/// @nodoc
class _$PathDataUserLocationCopyWithImpl<$Res>
    extends _$GlobalRoutePathCopyWithImpl<$Res>
    implements $PathDataUserLocationCopyWith<$Res> {
  _$PathDataUserLocationCopyWithImpl(
      PathDataUserLocation _value, $Res Function(PathDataUserLocation) _then)
      : super(_value, (v) => _then(v as PathDataUserLocation));

  @override
  PathDataUserLocation get _value => super._value as PathDataUserLocation;

  @override
  $Res call({
    Object userLocation = freezed,
  }) {
    return _then(PathDataUserLocation(
      userLocation == freezed
          ? _value.userLocation
          : userLocation as UserLocation,
    ));
  }
}

/// @nodoc
class _$PathDataUserLocation implements PathDataUserLocation {
  const _$PathDataUserLocation(this.userLocation)
      : assert(userLocation != null);

  @override
  final UserLocation userLocation;

  @override
  String toString() {
    return 'GlobalRoutePath.editUserLocation(userLocation: $userLocation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PathDataUserLocation &&
            (identical(other.userLocation, userLocation) ||
                const DeepCollectionEquality()
                    .equals(other.userLocation, userLocation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(userLocation);

  @override
  $PathDataUserLocationCopyWith<PathDataUserLocation> get copyWith =>
      _$PathDataUserLocationCopyWithImpl<PathDataUserLocation>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult intro(),
    @required TResult error(),
    @required TResult channel(String channelId),
    @required TResult program(String programId),
    @required TResult editUserLocation(UserLocation userLocation),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return editUserLocation(userLocation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult intro(),
    TResult error(),
    TResult channel(String channelId),
    TResult program(String programId),
    TResult editUserLocation(UserLocation userLocation),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (editUserLocation != null) {
      return editUserLocation(userLocation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult intro(PathDataIntro value),
    @required TResult error(PathDataError value),
    @required TResult channel(PathDataChannel value),
    @required TResult program(PathDataProgram value),
    @required TResult editUserLocation(PathDataUserLocation value),
  }) {
    assert(intro != null);
    assert(error != null);
    assert(channel != null);
    assert(program != null);
    assert(editUserLocation != null);
    return editUserLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult intro(PathDataIntro value),
    TResult error(PathDataError value),
    TResult channel(PathDataChannel value),
    TResult program(PathDataProgram value),
    TResult editUserLocation(PathDataUserLocation value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (editUserLocation != null) {
      return editUserLocation(this);
    }
    return orElse();
  }
}

abstract class PathDataUserLocation implements GlobalRoutePath {
  const factory PathDataUserLocation(UserLocation userLocation) =
      _$PathDataUserLocation;

  UserLocation get userLocation;
  $PathDataUserLocationCopyWith<PathDataUserLocation> get copyWith;
}

/// @nodoc
class _$PathDataMainPageBaseTearOff {
  const _$PathDataMainPageBaseTearOff();

// ignore: unused_element
  PathDataMainPageDashBoard dashboard() {
    return const PathDataMainPageDashBoard();
  }

// ignore: unused_element
  PathDataMainPageSubscribing subscribing(SubscribingTabPage index) {
    return PathDataMainPageSubscribing(
      index,
    );
  }

// ignore: unused_element
  PathDataMainPageSetting setting() {
    return const PathDataMainPageSetting();
  }
}

/// @nodoc
// ignore: unused_element
const $PathDataMainPageBase = _$PathDataMainPageBaseTearOff();

/// @nodoc
mixin _$PathDataMainPageBase {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dashboard(),
    @required TResult subscribing(SubscribingTabPage index),
    @required TResult setting(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dashboard(),
    TResult subscribing(SubscribingTabPage index),
    TResult setting(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dashboard(PathDataMainPageDashBoard value),
    @required TResult subscribing(PathDataMainPageSubscribing value),
    @required TResult setting(PathDataMainPageSetting value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dashboard(PathDataMainPageDashBoard value),
    TResult subscribing(PathDataMainPageSubscribing value),
    TResult setting(PathDataMainPageSetting value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PathDataMainPageBaseCopyWith<$Res> {
  factory $PathDataMainPageBaseCopyWith(PathDataMainPageBase value,
          $Res Function(PathDataMainPageBase) then) =
      _$PathDataMainPageBaseCopyWithImpl<$Res>;
}

/// @nodoc
class _$PathDataMainPageBaseCopyWithImpl<$Res>
    implements $PathDataMainPageBaseCopyWith<$Res> {
  _$PathDataMainPageBaseCopyWithImpl(this._value, this._then);

  final PathDataMainPageBase _value;
  // ignore: unused_field
  final $Res Function(PathDataMainPageBase) _then;
}

/// @nodoc
abstract class $PathDataMainPageDashBoardCopyWith<$Res> {
  factory $PathDataMainPageDashBoardCopyWith(PathDataMainPageDashBoard value,
          $Res Function(PathDataMainPageDashBoard) then) =
      _$PathDataMainPageDashBoardCopyWithImpl<$Res>;
}

/// @nodoc
class _$PathDataMainPageDashBoardCopyWithImpl<$Res>
    extends _$PathDataMainPageBaseCopyWithImpl<$Res>
    implements $PathDataMainPageDashBoardCopyWith<$Res> {
  _$PathDataMainPageDashBoardCopyWithImpl(PathDataMainPageDashBoard _value,
      $Res Function(PathDataMainPageDashBoard) _then)
      : super(_value, (v) => _then(v as PathDataMainPageDashBoard));

  @override
  PathDataMainPageDashBoard get _value =>
      super._value as PathDataMainPageDashBoard;
}

/// @nodoc
class _$PathDataMainPageDashBoard extends PathDataMainPageDashBoard {
  const _$PathDataMainPageDashBoard() : super._();

  @override
  String toString() {
    return 'PathDataMainPageBase.dashboard()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PathDataMainPageDashBoard);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dashboard(),
    @required TResult subscribing(SubscribingTabPage index),
    @required TResult setting(),
  }) {
    assert(dashboard != null);
    assert(subscribing != null);
    assert(setting != null);
    return dashboard();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dashboard(),
    TResult subscribing(SubscribingTabPage index),
    TResult setting(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (dashboard != null) {
      return dashboard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dashboard(PathDataMainPageDashBoard value),
    @required TResult subscribing(PathDataMainPageSubscribing value),
    @required TResult setting(PathDataMainPageSetting value),
  }) {
    assert(dashboard != null);
    assert(subscribing != null);
    assert(setting != null);
    return dashboard(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dashboard(PathDataMainPageDashBoard value),
    TResult subscribing(PathDataMainPageSubscribing value),
    TResult setting(PathDataMainPageSetting value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (dashboard != null) {
      return dashboard(this);
    }
    return orElse();
  }
}

abstract class PathDataMainPageDashBoard extends PathDataMainPageBase {
  const PathDataMainPageDashBoard._() : super._();
  const factory PathDataMainPageDashBoard() = _$PathDataMainPageDashBoard;
}

/// @nodoc
abstract class $PathDataMainPageSubscribingCopyWith<$Res> {
  factory $PathDataMainPageSubscribingCopyWith(
          PathDataMainPageSubscribing value,
          $Res Function(PathDataMainPageSubscribing) then) =
      _$PathDataMainPageSubscribingCopyWithImpl<$Res>;
  $Res call({SubscribingTabPage index});
}

/// @nodoc
class _$PathDataMainPageSubscribingCopyWithImpl<$Res>
    extends _$PathDataMainPageBaseCopyWithImpl<$Res>
    implements $PathDataMainPageSubscribingCopyWith<$Res> {
  _$PathDataMainPageSubscribingCopyWithImpl(PathDataMainPageSubscribing _value,
      $Res Function(PathDataMainPageSubscribing) _then)
      : super(_value, (v) => _then(v as PathDataMainPageSubscribing));

  @override
  PathDataMainPageSubscribing get _value =>
      super._value as PathDataMainPageSubscribing;

  @override
  $Res call({
    Object index = freezed,
  }) {
    return _then(PathDataMainPageSubscribing(
      index == freezed ? _value.index : index as SubscribingTabPage,
    ));
  }
}

/// @nodoc
class _$PathDataMainPageSubscribing extends PathDataMainPageSubscribing {
  const _$PathDataMainPageSubscribing(this.index)
      : assert(index != null),
        super._();

  @override
  final SubscribingTabPage index;

  @override
  String toString() {
    return 'PathDataMainPageBase.subscribing(index: $index)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PathDataMainPageSubscribing &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(index);

  @override
  $PathDataMainPageSubscribingCopyWith<PathDataMainPageSubscribing>
      get copyWith => _$PathDataMainPageSubscribingCopyWithImpl<
          PathDataMainPageSubscribing>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dashboard(),
    @required TResult subscribing(SubscribingTabPage index),
    @required TResult setting(),
  }) {
    assert(dashboard != null);
    assert(subscribing != null);
    assert(setting != null);
    return subscribing(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dashboard(),
    TResult subscribing(SubscribingTabPage index),
    TResult setting(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (subscribing != null) {
      return subscribing(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dashboard(PathDataMainPageDashBoard value),
    @required TResult subscribing(PathDataMainPageSubscribing value),
    @required TResult setting(PathDataMainPageSetting value),
  }) {
    assert(dashboard != null);
    assert(subscribing != null);
    assert(setting != null);
    return subscribing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dashboard(PathDataMainPageDashBoard value),
    TResult subscribing(PathDataMainPageSubscribing value),
    TResult setting(PathDataMainPageSetting value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (subscribing != null) {
      return subscribing(this);
    }
    return orElse();
  }
}

abstract class PathDataMainPageSubscribing extends PathDataMainPageBase {
  const PathDataMainPageSubscribing._() : super._();
  const factory PathDataMainPageSubscribing(SubscribingTabPage index) =
      _$PathDataMainPageSubscribing;

  SubscribingTabPage get index;
  $PathDataMainPageSubscribingCopyWith<PathDataMainPageSubscribing>
      get copyWith;
}

/// @nodoc
abstract class $PathDataMainPageSettingCopyWith<$Res> {
  factory $PathDataMainPageSettingCopyWith(PathDataMainPageSetting value,
          $Res Function(PathDataMainPageSetting) then) =
      _$PathDataMainPageSettingCopyWithImpl<$Res>;
}

/// @nodoc
class _$PathDataMainPageSettingCopyWithImpl<$Res>
    extends _$PathDataMainPageBaseCopyWithImpl<$Res>
    implements $PathDataMainPageSettingCopyWith<$Res> {
  _$PathDataMainPageSettingCopyWithImpl(PathDataMainPageSetting _value,
      $Res Function(PathDataMainPageSetting) _then)
      : super(_value, (v) => _then(v as PathDataMainPageSetting));

  @override
  PathDataMainPageSetting get _value => super._value as PathDataMainPageSetting;
}

/// @nodoc
class _$PathDataMainPageSetting extends PathDataMainPageSetting {
  const _$PathDataMainPageSetting() : super._();

  @override
  String toString() {
    return 'PathDataMainPageBase.setting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PathDataMainPageSetting);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dashboard(),
    @required TResult subscribing(SubscribingTabPage index),
    @required TResult setting(),
  }) {
    assert(dashboard != null);
    assert(subscribing != null);
    assert(setting != null);
    return setting();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dashboard(),
    TResult subscribing(SubscribingTabPage index),
    TResult setting(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (setting != null) {
      return setting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dashboard(PathDataMainPageDashBoard value),
    @required TResult subscribing(PathDataMainPageSubscribing value),
    @required TResult setting(PathDataMainPageSetting value),
  }) {
    assert(dashboard != null);
    assert(subscribing != null);
    assert(setting != null);
    return setting(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dashboard(PathDataMainPageDashBoard value),
    TResult subscribing(PathDataMainPageSubscribing value),
    TResult setting(PathDataMainPageSetting value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (setting != null) {
      return setting(this);
    }
    return orElse();
  }
}

abstract class PathDataMainPageSetting extends PathDataMainPageBase {
  const PathDataMainPageSetting._() : super._();
  const factory PathDataMainPageSetting() = _$PathDataMainPageSetting;
}
