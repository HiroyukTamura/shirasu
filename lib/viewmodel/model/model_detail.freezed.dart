// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'model_detail.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ModelDetailTearOff {
  const _$ModelDetailTearOff();

// ignore: unused_element
  _ModelDetail call(
      {@required DetailModelState prgDataResult,
      @required PlayOutState playOutState,
      @required bool isHandoutUrlRequesting,
      @required bool isCommentPosting,
      @required CommentsHolder commentHolder,
      @required BtmSheetState btmSheetState}) {
    return _ModelDetail(
      prgDataResult: prgDataResult,
      playOutState: playOutState,
      isHandoutUrlRequesting: isHandoutUrlRequesting,
      isCommentPosting: isCommentPosting,
      commentHolder: commentHolder,
      btmSheetState: btmSheetState,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ModelDetail = _$ModelDetailTearOff();

/// @nodoc
mixin _$ModelDetail {
  DetailModelState get prgDataResult;
  PlayOutState get playOutState;
  bool get isHandoutUrlRequesting;
  bool get isCommentPosting;
  CommentsHolder get commentHolder;
  BtmSheetState get btmSheetState;

  @JsonKey(ignore: true)
  $ModelDetailCopyWith<ModelDetail> get copyWith;
}

/// @nodoc
abstract class $ModelDetailCopyWith<$Res> {
  factory $ModelDetailCopyWith(
          ModelDetail value, $Res Function(ModelDetail) then) =
      _$ModelDetailCopyWithImpl<$Res>;
  $Res call(
      {DetailModelState prgDataResult,
      PlayOutState playOutState,
      bool isHandoutUrlRequesting,
      bool isCommentPosting,
      CommentsHolder commentHolder,
      BtmSheetState btmSheetState});

  $DetailModelStateCopyWith<$Res> get prgDataResult;
  $PlayOutStateCopyWith<$Res> get playOutState;
  $CommentsHolderCopyWith<$Res> get commentHolder;
  $BtmSheetStateCopyWith<$Res> get btmSheetState;
}

/// @nodoc
class _$ModelDetailCopyWithImpl<$Res> implements $ModelDetailCopyWith<$Res> {
  _$ModelDetailCopyWithImpl(this._value, this._then);

  final ModelDetail _value;
  // ignore: unused_field
  final $Res Function(ModelDetail) _then;

  @override
  $Res call({
    Object prgDataResult = freezed,
    Object playOutState = freezed,
    Object isHandoutUrlRequesting = freezed,
    Object isCommentPosting = freezed,
    Object commentHolder = freezed,
    Object btmSheetState = freezed,
  }) {
    return _then(_value.copyWith(
      prgDataResult: prgDataResult == freezed
          ? _value.prgDataResult
          : prgDataResult as DetailModelState,
      playOutState: playOutState == freezed
          ? _value.playOutState
          : playOutState as PlayOutState,
      isHandoutUrlRequesting: isHandoutUrlRequesting == freezed
          ? _value.isHandoutUrlRequesting
          : isHandoutUrlRequesting as bool,
      isCommentPosting: isCommentPosting == freezed
          ? _value.isCommentPosting
          : isCommentPosting as bool,
      commentHolder: commentHolder == freezed
          ? _value.commentHolder
          : commentHolder as CommentsHolder,
      btmSheetState: btmSheetState == freezed
          ? _value.btmSheetState
          : btmSheetState as BtmSheetState,
    ));
  }

  @override
  $DetailModelStateCopyWith<$Res> get prgDataResult {
    if (_value.prgDataResult == null) {
      return null;
    }
    return $DetailModelStateCopyWith<$Res>(_value.prgDataResult, (value) {
      return _then(_value.copyWith(prgDataResult: value));
    });
  }

  @override
  $PlayOutStateCopyWith<$Res> get playOutState {
    if (_value.playOutState == null) {
      return null;
    }
    return $PlayOutStateCopyWith<$Res>(_value.playOutState, (value) {
      return _then(_value.copyWith(playOutState: value));
    });
  }

  @override
  $CommentsHolderCopyWith<$Res> get commentHolder {
    if (_value.commentHolder == null) {
      return null;
    }
    return $CommentsHolderCopyWith<$Res>(_value.commentHolder, (value) {
      return _then(_value.copyWith(commentHolder: value));
    });
  }

  @override
  $BtmSheetStateCopyWith<$Res> get btmSheetState {
    if (_value.btmSheetState == null) {
      return null;
    }
    return $BtmSheetStateCopyWith<$Res>(_value.btmSheetState, (value) {
      return _then(_value.copyWith(btmSheetState: value));
    });
  }
}

/// @nodoc
abstract class _$ModelDetailCopyWith<$Res>
    implements $ModelDetailCopyWith<$Res> {
  factory _$ModelDetailCopyWith(
          _ModelDetail value, $Res Function(_ModelDetail) then) =
      __$ModelDetailCopyWithImpl<$Res>;
  @override
  $Res call(
      {DetailModelState prgDataResult,
      PlayOutState playOutState,
      bool isHandoutUrlRequesting,
      bool isCommentPosting,
      CommentsHolder commentHolder,
      BtmSheetState btmSheetState});

  @override
  $DetailModelStateCopyWith<$Res> get prgDataResult;
  @override
  $PlayOutStateCopyWith<$Res> get playOutState;
  @override
  $CommentsHolderCopyWith<$Res> get commentHolder;
  @override
  $BtmSheetStateCopyWith<$Res> get btmSheetState;
}

/// @nodoc
class __$ModelDetailCopyWithImpl<$Res> extends _$ModelDetailCopyWithImpl<$Res>
    implements _$ModelDetailCopyWith<$Res> {
  __$ModelDetailCopyWithImpl(
      _ModelDetail _value, $Res Function(_ModelDetail) _then)
      : super(_value, (v) => _then(v as _ModelDetail));

  @override
  _ModelDetail get _value => super._value as _ModelDetail;

  @override
  $Res call({
    Object prgDataResult = freezed,
    Object playOutState = freezed,
    Object isHandoutUrlRequesting = freezed,
    Object isCommentPosting = freezed,
    Object commentHolder = freezed,
    Object btmSheetState = freezed,
  }) {
    return _then(_ModelDetail(
      prgDataResult: prgDataResult == freezed
          ? _value.prgDataResult
          : prgDataResult as DetailModelState,
      playOutState: playOutState == freezed
          ? _value.playOutState
          : playOutState as PlayOutState,
      isHandoutUrlRequesting: isHandoutUrlRequesting == freezed
          ? _value.isHandoutUrlRequesting
          : isHandoutUrlRequesting as bool,
      isCommentPosting: isCommentPosting == freezed
          ? _value.isCommentPosting
          : isCommentPosting as bool,
      commentHolder: commentHolder == freezed
          ? _value.commentHolder
          : commentHolder as CommentsHolder,
      btmSheetState: btmSheetState == freezed
          ? _value.btmSheetState
          : btmSheetState as BtmSheetState,
    ));
  }
}

@protected

/// @nodoc
class _$_ModelDetail extends _ModelDetail {
  const _$_ModelDetail(
      {@required this.prgDataResult,
      @required this.playOutState,
      @required this.isHandoutUrlRequesting,
      @required this.isCommentPosting,
      @required this.commentHolder,
      @required this.btmSheetState})
      : assert(prgDataResult != null),
        assert(playOutState != null),
        assert(isHandoutUrlRequesting != null),
        assert(isCommentPosting != null),
        assert(commentHolder != null),
        assert(btmSheetState != null),
        super._();

  @override
  final DetailModelState prgDataResult;
  @override
  final PlayOutState playOutState;
  @override
  final bool isHandoutUrlRequesting;
  @override
  final bool isCommentPosting;
  @override
  final CommentsHolder commentHolder;
  @override
  final BtmSheetState btmSheetState;

  @override
  String toString() {
    return 'ModelDetail(prgDataResult: $prgDataResult, playOutState: $playOutState, isHandoutUrlRequesting: $isHandoutUrlRequesting, isCommentPosting: $isCommentPosting, commentHolder: $commentHolder, btmSheetState: $btmSheetState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelDetail &&
            (identical(other.prgDataResult, prgDataResult) ||
                const DeepCollectionEquality()
                    .equals(other.prgDataResult, prgDataResult)) &&
            (identical(other.playOutState, playOutState) ||
                const DeepCollectionEquality()
                    .equals(other.playOutState, playOutState)) &&
            (identical(other.isHandoutUrlRequesting, isHandoutUrlRequesting) ||
                const DeepCollectionEquality().equals(
                    other.isHandoutUrlRequesting, isHandoutUrlRequesting)) &&
            (identical(other.isCommentPosting, isCommentPosting) ||
                const DeepCollectionEquality()
                    .equals(other.isCommentPosting, isCommentPosting)) &&
            (identical(other.commentHolder, commentHolder) ||
                const DeepCollectionEquality()
                    .equals(other.commentHolder, commentHolder)) &&
            (identical(other.btmSheetState, btmSheetState) ||
                const DeepCollectionEquality()
                    .equals(other.btmSheetState, btmSheetState)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(prgDataResult) ^
      const DeepCollectionEquality().hash(playOutState) ^
      const DeepCollectionEquality().hash(isHandoutUrlRequesting) ^
      const DeepCollectionEquality().hash(isCommentPosting) ^
      const DeepCollectionEquality().hash(commentHolder) ^
      const DeepCollectionEquality().hash(btmSheetState);

  @JsonKey(ignore: true)
  @override
  _$ModelDetailCopyWith<_ModelDetail> get copyWith =>
      __$ModelDetailCopyWithImpl<_ModelDetail>(this, _$identity);
}

abstract class _ModelDetail extends ModelDetail {
  const _ModelDetail._() : super._();
  const factory _ModelDetail(
      {@required DetailModelState prgDataResult,
      @required PlayOutState playOutState,
      @required bool isHandoutUrlRequesting,
      @required bool isCommentPosting,
      @required CommentsHolder commentHolder,
      @required BtmSheetState btmSheetState}) = _$_ModelDetail;

  @override
  DetailModelState get prgDataResult;
  @override
  PlayOutState get playOutState;
  @override
  bool get isHandoutUrlRequesting;
  @override
  bool get isCommentPosting;
  @override
  CommentsHolder get commentHolder;
  @override
  BtmSheetState get btmSheetState;
  @override
  @JsonKey(ignore: true)
  _$ModelDetailCopyWith<_ModelDetail> get copyWith;
}

/// @nodoc
class _$DetailModelStateTearOff {
  const _$DetailModelStateTearOff();

// ignore: unused_element
  _DetailPreInitialized preInitialized() {
    return const _DetailPreInitialized();
  }

// ignore: unused_element
  _DetailStateLoading loading() {
    return const _DetailStateLoading();
  }

// ignore: unused_element
  DetailStateSuccess success(
      {@required ProgramDetailData programDetailData,
      @required ChannelData channelData,
      @required PageSheetModel page}) {
    return DetailStateSuccess(
      programDetailData: programDetailData,
      channelData: channelData,
      page: page,
    );
  }

// ignore: unused_element
  _DetailStateError error(ErrorMsgCommon msg) {
    return _DetailStateError(
      msg,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $DetailModelState = _$DetailModelStateTearOff();

/// @nodoc
mixin _$DetailModelState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult loading(),
    @required
        TResult success(ProgramDetailData programDetailData,
            ChannelData channelData, PageSheetModel page),
    @required TResult error(ErrorMsgCommon msg),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult loading(),
    TResult success(ProgramDetailData programDetailData,
        ChannelData channelData, PageSheetModel page),
    TResult error(ErrorMsgCommon msg),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_DetailPreInitialized value),
    @required TResult loading(_DetailStateLoading value),
    @required TResult success(DetailStateSuccess value),
    @required TResult error(_DetailStateError value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_DetailPreInitialized value),
    TResult loading(_DetailStateLoading value),
    TResult success(DetailStateSuccess value),
    TResult error(_DetailStateError value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $DetailModelStateCopyWith<$Res> {
  factory $DetailModelStateCopyWith(
          DetailModelState value, $Res Function(DetailModelState) then) =
      _$DetailModelStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$DetailModelStateCopyWithImpl<$Res>
    implements $DetailModelStateCopyWith<$Res> {
  _$DetailModelStateCopyWithImpl(this._value, this._then);

  final DetailModelState _value;
  // ignore: unused_field
  final $Res Function(DetailModelState) _then;
}

/// @nodoc
abstract class _$DetailPreInitializedCopyWith<$Res> {
  factory _$DetailPreInitializedCopyWith(_DetailPreInitialized value,
          $Res Function(_DetailPreInitialized) then) =
      __$DetailPreInitializedCopyWithImpl<$Res>;
}

/// @nodoc
class __$DetailPreInitializedCopyWithImpl<$Res>
    extends _$DetailModelStateCopyWithImpl<$Res>
    implements _$DetailPreInitializedCopyWith<$Res> {
  __$DetailPreInitializedCopyWithImpl(
      _DetailPreInitialized _value, $Res Function(_DetailPreInitialized) _then)
      : super(_value, (v) => _then(v as _DetailPreInitialized));

  @override
  _DetailPreInitialized get _value => super._value as _DetailPreInitialized;
}

/// @nodoc
class _$_DetailPreInitialized extends _DetailPreInitialized {
  const _$_DetailPreInitialized() : super._();

  @override
  String toString() {
    return 'DetailModelState.preInitialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DetailPreInitialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult loading(),
    @required
        TResult success(ProgramDetailData programDetailData,
            ChannelData channelData, PageSheetModel page),
    @required TResult error(ErrorMsgCommon msg),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return preInitialized();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult loading(),
    TResult success(ProgramDetailData programDetailData,
        ChannelData channelData, PageSheetModel page),
    TResult error(ErrorMsgCommon msg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (preInitialized != null) {
      return preInitialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_DetailPreInitialized value),
    @required TResult loading(_DetailStateLoading value),
    @required TResult success(DetailStateSuccess value),
    @required TResult error(_DetailStateError value),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return preInitialized(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_DetailPreInitialized value),
    TResult loading(_DetailStateLoading value),
    TResult success(DetailStateSuccess value),
    TResult error(_DetailStateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (preInitialized != null) {
      return preInitialized(this);
    }
    return orElse();
  }
}

abstract class _DetailPreInitialized extends DetailModelState {
  const _DetailPreInitialized._() : super._();
  const factory _DetailPreInitialized() = _$_DetailPreInitialized;
}

/// @nodoc
abstract class _$DetailStateLoadingCopyWith<$Res> {
  factory _$DetailStateLoadingCopyWith(
          _DetailStateLoading value, $Res Function(_DetailStateLoading) then) =
      __$DetailStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$DetailStateLoadingCopyWithImpl<$Res>
    extends _$DetailModelStateCopyWithImpl<$Res>
    implements _$DetailStateLoadingCopyWith<$Res> {
  __$DetailStateLoadingCopyWithImpl(
      _DetailStateLoading _value, $Res Function(_DetailStateLoading) _then)
      : super(_value, (v) => _then(v as _DetailStateLoading));

  @override
  _DetailStateLoading get _value => super._value as _DetailStateLoading;
}

/// @nodoc
class _$_DetailStateLoading extends _DetailStateLoading {
  const _$_DetailStateLoading() : super._();

  @override
  String toString() {
    return 'DetailModelState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DetailStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult loading(),
    @required
        TResult success(ProgramDetailData programDetailData,
            ChannelData channelData, PageSheetModel page),
    @required TResult error(ErrorMsgCommon msg),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult loading(),
    TResult success(ProgramDetailData programDetailData,
        ChannelData channelData, PageSheetModel page),
    TResult error(ErrorMsgCommon msg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_DetailPreInitialized value),
    @required TResult loading(_DetailStateLoading value),
    @required TResult success(DetailStateSuccess value),
    @required TResult error(_DetailStateError value),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_DetailPreInitialized value),
    TResult loading(_DetailStateLoading value),
    TResult success(DetailStateSuccess value),
    TResult error(_DetailStateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _DetailStateLoading extends DetailModelState {
  const _DetailStateLoading._() : super._();
  const factory _DetailStateLoading() = _$_DetailStateLoading;
}

/// @nodoc
abstract class $DetailStateSuccessCopyWith<$Res> {
  factory $DetailStateSuccessCopyWith(
          DetailStateSuccess value, $Res Function(DetailStateSuccess) then) =
      _$DetailStateSuccessCopyWithImpl<$Res>;
  $Res call(
      {ProgramDetailData programDetailData,
      ChannelData channelData,
      PageSheetModel page});

  $ProgramDetailDataCopyWith<$Res> get programDetailData;
  $ChannelDataCopyWith<$Res> get channelData;
  $PageSheetModelCopyWith<$Res> get page;
}

/// @nodoc
class _$DetailStateSuccessCopyWithImpl<$Res>
    extends _$DetailModelStateCopyWithImpl<$Res>
    implements $DetailStateSuccessCopyWith<$Res> {
  _$DetailStateSuccessCopyWithImpl(
      DetailStateSuccess _value, $Res Function(DetailStateSuccess) _then)
      : super(_value, (v) => _then(v as DetailStateSuccess));

  @override
  DetailStateSuccess get _value => super._value as DetailStateSuccess;

  @override
  $Res call({
    Object programDetailData = freezed,
    Object channelData = freezed,
    Object page = freezed,
  }) {
    return _then(DetailStateSuccess(
      programDetailData: programDetailData == freezed
          ? _value.programDetailData
          : programDetailData as ProgramDetailData,
      channelData: channelData == freezed
          ? _value.channelData
          : channelData as ChannelData,
      page: page == freezed ? _value.page : page as PageSheetModel,
    ));
  }

  @override
  $ProgramDetailDataCopyWith<$Res> get programDetailData {
    if (_value.programDetailData == null) {
      return null;
    }
    return $ProgramDetailDataCopyWith<$Res>(_value.programDetailData, (value) {
      return _then(_value.copyWith(programDetailData: value));
    });
  }

  @override
  $ChannelDataCopyWith<$Res> get channelData {
    if (_value.channelData == null) {
      return null;
    }
    return $ChannelDataCopyWith<$Res>(_value.channelData, (value) {
      return _then(_value.copyWith(channelData: value));
    });
  }

  @override
  $PageSheetModelCopyWith<$Res> get page {
    if (_value.page == null) {
      return null;
    }
    return $PageSheetModelCopyWith<$Res>(_value.page, (value) {
      return _then(_value.copyWith(page: value));
    });
  }
}

/// @nodoc
class _$DetailStateSuccess extends DetailStateSuccess {
  const _$DetailStateSuccess(
      {@required this.programDetailData,
      @required this.channelData,
      @required this.page})
      : assert(programDetailData != null),
        assert(channelData != null),
        assert(page != null),
        super._();

  @override
  final ProgramDetailData programDetailData;
  @override
  final ChannelData channelData;
  @override
  final PageSheetModel page;

  @override
  String toString() {
    return 'DetailModelState.success(programDetailData: $programDetailData, channelData: $channelData, page: $page)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailStateSuccess &&
            (identical(other.programDetailData, programDetailData) ||
                const DeepCollectionEquality()
                    .equals(other.programDetailData, programDetailData)) &&
            (identical(other.channelData, channelData) ||
                const DeepCollectionEquality()
                    .equals(other.channelData, channelData)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(programDetailData) ^
      const DeepCollectionEquality().hash(channelData) ^
      const DeepCollectionEquality().hash(page);

  @JsonKey(ignore: true)
  @override
  $DetailStateSuccessCopyWith<DetailStateSuccess> get copyWith =>
      _$DetailStateSuccessCopyWithImpl<DetailStateSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult loading(),
    @required
        TResult success(ProgramDetailData programDetailData,
            ChannelData channelData, PageSheetModel page),
    @required TResult error(ErrorMsgCommon msg),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return success(programDetailData, channelData, page);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult loading(),
    TResult success(ProgramDetailData programDetailData,
        ChannelData channelData, PageSheetModel page),
    TResult error(ErrorMsgCommon msg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (success != null) {
      return success(programDetailData, channelData, page);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_DetailPreInitialized value),
    @required TResult loading(_DetailStateLoading value),
    @required TResult success(DetailStateSuccess value),
    @required TResult error(_DetailStateError value),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_DetailPreInitialized value),
    TResult loading(_DetailStateLoading value),
    TResult success(DetailStateSuccess value),
    TResult error(_DetailStateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class DetailStateSuccess extends DetailModelState {
  const DetailStateSuccess._() : super._();
  const factory DetailStateSuccess(
      {@required ProgramDetailData programDetailData,
      @required ChannelData channelData,
      @required PageSheetModel page}) = _$DetailStateSuccess;

  ProgramDetailData get programDetailData;
  ChannelData get channelData;
  PageSheetModel get page;
  @JsonKey(ignore: true)
  $DetailStateSuccessCopyWith<DetailStateSuccess> get copyWith;
}

/// @nodoc
abstract class _$DetailStateErrorCopyWith<$Res> {
  factory _$DetailStateErrorCopyWith(
          _DetailStateError value, $Res Function(_DetailStateError) then) =
      __$DetailStateErrorCopyWithImpl<$Res>;
  $Res call({ErrorMsgCommon msg});

  $ErrorMsgCommonCopyWith<$Res> get msg;
}

/// @nodoc
class __$DetailStateErrorCopyWithImpl<$Res>
    extends _$DetailModelStateCopyWithImpl<$Res>
    implements _$DetailStateErrorCopyWith<$Res> {
  __$DetailStateErrorCopyWithImpl(
      _DetailStateError _value, $Res Function(_DetailStateError) _then)
      : super(_value, (v) => _then(v as _DetailStateError));

  @override
  _DetailStateError get _value => super._value as _DetailStateError;

  @override
  $Res call({
    Object msg = freezed,
  }) {
    return _then(_DetailStateError(
      msg == freezed ? _value.msg : msg as ErrorMsgCommon,
    ));
  }

  @override
  $ErrorMsgCommonCopyWith<$Res> get msg {
    if (_value.msg == null) {
      return null;
    }
    return $ErrorMsgCommonCopyWith<$Res>(_value.msg, (value) {
      return _then(_value.copyWith(msg: value));
    });
  }
}

/// @nodoc
class _$_DetailStateError extends _DetailStateError {
  const _$_DetailStateError(this.msg)
      : assert(msg != null),
        super._();

  @override
  final ErrorMsgCommon msg;

  @override
  String toString() {
    return 'DetailModelState.error(msg: $msg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DetailStateError &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(msg);

  @JsonKey(ignore: true)
  @override
  _$DetailStateErrorCopyWith<_DetailStateError> get copyWith =>
      __$DetailStateErrorCopyWithImpl<_DetailStateError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult loading(),
    @required
        TResult success(ProgramDetailData programDetailData,
            ChannelData channelData, PageSheetModel page),
    @required TResult error(ErrorMsgCommon msg),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return error(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult loading(),
    TResult success(ProgramDetailData programDetailData,
        ChannelData channelData, PageSheetModel page),
    TResult error(ErrorMsgCommon msg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_DetailPreInitialized value),
    @required TResult loading(_DetailStateLoading value),
    @required TResult success(DetailStateSuccess value),
    @required TResult error(_DetailStateError value),
  }) {
    assert(preInitialized != null);
    assert(loading != null);
    assert(success != null);
    assert(error != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_DetailPreInitialized value),
    TResult loading(_DetailStateLoading value),
    TResult success(DetailStateSuccess value),
    TResult error(_DetailStateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _DetailStateError extends DetailModelState {
  const _DetailStateError._() : super._();
  const factory _DetailStateError(ErrorMsgCommon msg) = _$_DetailStateError;

  ErrorMsgCommon get msg;
  @JsonKey(ignore: true)
  _$DetailStateErrorCopyWith<_DetailStateError> get copyWith;
}

/// @nodoc
class _$PlayOutStateTearOff {
  const _$PlayOutStateTearOff();

// ignore: unused_element
  _PlayOutState call(
      {@required PlayerCommandedState commandedState,
      String hlsMediaUrl,
      VideoType videoType,
      String cookie,
      bool isPlaying = false,
      @nullable @protected Duration currentPos,
      @nullable @protected Duration currentPosForUi,
      @nullable @protected Duration totalDuration,
      bool controllerVisibility = false,
      bool isSeekBarDragging = false,
      bool fullScreen = false,
      bool isBuffering = false,
      VideoPlayerState videoPlayerState =
          const VideoPlayerState.preInitialized(),
      LastControllerCommandHolder lastControllerCommandHolder =
          const LastControllerCommandHolder()}) {
    return _PlayOutState(
      commandedState: commandedState,
      hlsMediaUrl: hlsMediaUrl,
      videoType: videoType,
      cookie: cookie,
      isPlaying: isPlaying,
      currentPos: currentPos,
      currentPosForUi: currentPosForUi,
      totalDuration: totalDuration,
      controllerVisibility: controllerVisibility,
      isSeekBarDragging: isSeekBarDragging,
      fullScreen: fullScreen,
      isBuffering: isBuffering,
      videoPlayerState: videoPlayerState,
      lastControllerCommandHolder: lastControllerCommandHolder,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $PlayOutState = _$PlayOutStateTearOff();

/// @nodoc
mixin _$PlayOutState {
  PlayerCommandedState get commandedState;
  String get hlsMediaUrl;
  VideoType get videoType;
  String get cookie;
  bool get isPlaying;
  @nullable
  @protected
  Duration get currentPos;
  @nullable
  @protected
  Duration get currentPosForUi;
  @nullable
  @protected
  Duration get totalDuration;
  bool get controllerVisibility;
  bool get isSeekBarDragging;
  bool get fullScreen;
  bool get isBuffering;
  VideoPlayerState get videoPlayerState;
  LastControllerCommandHolder get lastControllerCommandHolder;

  @JsonKey(ignore: true)
  $PlayOutStateCopyWith<PlayOutState> get copyWith;
}

/// @nodoc
abstract class $PlayOutStateCopyWith<$Res> {
  factory $PlayOutStateCopyWith(
          PlayOutState value, $Res Function(PlayOutState) then) =
      _$PlayOutStateCopyWithImpl<$Res>;
  $Res call(
      {PlayerCommandedState commandedState,
      String hlsMediaUrl,
      VideoType videoType,
      String cookie,
      bool isPlaying,
      @nullable @protected Duration currentPos,
      @nullable @protected Duration currentPosForUi,
      @nullable @protected Duration totalDuration,
      bool controllerVisibility,
      bool isSeekBarDragging,
      bool fullScreen,
      bool isBuffering,
      VideoPlayerState videoPlayerState,
      LastControllerCommandHolder lastControllerCommandHolder});

  $PlayerCommandedStateCopyWith<$Res> get commandedState;
  $VideoTypeCopyWith<$Res> get videoType;
  $VideoPlayerStateCopyWith<$Res> get videoPlayerState;
  $LastControllerCommandHolderCopyWith<$Res> get lastControllerCommandHolder;
}

/// @nodoc
class _$PlayOutStateCopyWithImpl<$Res> implements $PlayOutStateCopyWith<$Res> {
  _$PlayOutStateCopyWithImpl(this._value, this._then);

  final PlayOutState _value;
  // ignore: unused_field
  final $Res Function(PlayOutState) _then;

  @override
  $Res call({
    Object commandedState = freezed,
    Object hlsMediaUrl = freezed,
    Object videoType = freezed,
    Object cookie = freezed,
    Object isPlaying = freezed,
    Object currentPos = freezed,
    Object currentPosForUi = freezed,
    Object totalDuration = freezed,
    Object controllerVisibility = freezed,
    Object isSeekBarDragging = freezed,
    Object fullScreen = freezed,
    Object isBuffering = freezed,
    Object videoPlayerState = freezed,
    Object lastControllerCommandHolder = freezed,
  }) {
    return _then(_value.copyWith(
      commandedState: commandedState == freezed
          ? _value.commandedState
          : commandedState as PlayerCommandedState,
      hlsMediaUrl:
          hlsMediaUrl == freezed ? _value.hlsMediaUrl : hlsMediaUrl as String,
      videoType:
          videoType == freezed ? _value.videoType : videoType as VideoType,
      cookie: cookie == freezed ? _value.cookie : cookie as String,
      isPlaying: isPlaying == freezed ? _value.isPlaying : isPlaying as bool,
      currentPos:
          currentPos == freezed ? _value.currentPos : currentPos as Duration,
      currentPosForUi: currentPosForUi == freezed
          ? _value.currentPosForUi
          : currentPosForUi as Duration,
      totalDuration: totalDuration == freezed
          ? _value.totalDuration
          : totalDuration as Duration,
      controllerVisibility: controllerVisibility == freezed
          ? _value.controllerVisibility
          : controllerVisibility as bool,
      isSeekBarDragging: isSeekBarDragging == freezed
          ? _value.isSeekBarDragging
          : isSeekBarDragging as bool,
      fullScreen:
          fullScreen == freezed ? _value.fullScreen : fullScreen as bool,
      isBuffering:
          isBuffering == freezed ? _value.isBuffering : isBuffering as bool,
      videoPlayerState: videoPlayerState == freezed
          ? _value.videoPlayerState
          : videoPlayerState as VideoPlayerState,
      lastControllerCommandHolder: lastControllerCommandHolder == freezed
          ? _value.lastControllerCommandHolder
          : lastControllerCommandHolder as LastControllerCommandHolder,
    ));
  }

  @override
  $PlayerCommandedStateCopyWith<$Res> get commandedState {
    if (_value.commandedState == null) {
      return null;
    }
    return $PlayerCommandedStateCopyWith<$Res>(_value.commandedState, (value) {
      return _then(_value.copyWith(commandedState: value));
    });
  }

  @override
  $VideoTypeCopyWith<$Res> get videoType {
    if (_value.videoType == null) {
      return null;
    }
    return $VideoTypeCopyWith<$Res>(_value.videoType, (value) {
      return _then(_value.copyWith(videoType: value));
    });
  }

  @override
  $VideoPlayerStateCopyWith<$Res> get videoPlayerState {
    if (_value.videoPlayerState == null) {
      return null;
    }
    return $VideoPlayerStateCopyWith<$Res>(_value.videoPlayerState, (value) {
      return _then(_value.copyWith(videoPlayerState: value));
    });
  }

  @override
  $LastControllerCommandHolderCopyWith<$Res> get lastControllerCommandHolder {
    if (_value.lastControllerCommandHolder == null) {
      return null;
    }
    return $LastControllerCommandHolderCopyWith<$Res>(
        _value.lastControllerCommandHolder, (value) {
      return _then(_value.copyWith(lastControllerCommandHolder: value));
    });
  }
}

/// @nodoc
abstract class _$PlayOutStateCopyWith<$Res>
    implements $PlayOutStateCopyWith<$Res> {
  factory _$PlayOutStateCopyWith(
          _PlayOutState value, $Res Function(_PlayOutState) then) =
      __$PlayOutStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {PlayerCommandedState commandedState,
      String hlsMediaUrl,
      VideoType videoType,
      String cookie,
      bool isPlaying,
      @nullable @protected Duration currentPos,
      @nullable @protected Duration currentPosForUi,
      @nullable @protected Duration totalDuration,
      bool controllerVisibility,
      bool isSeekBarDragging,
      bool fullScreen,
      bool isBuffering,
      VideoPlayerState videoPlayerState,
      LastControllerCommandHolder lastControllerCommandHolder});

  @override
  $PlayerCommandedStateCopyWith<$Res> get commandedState;
  @override
  $VideoTypeCopyWith<$Res> get videoType;
  @override
  $VideoPlayerStateCopyWith<$Res> get videoPlayerState;
  @override
  $LastControllerCommandHolderCopyWith<$Res> get lastControllerCommandHolder;
}

/// @nodoc
class __$PlayOutStateCopyWithImpl<$Res> extends _$PlayOutStateCopyWithImpl<$Res>
    implements _$PlayOutStateCopyWith<$Res> {
  __$PlayOutStateCopyWithImpl(
      _PlayOutState _value, $Res Function(_PlayOutState) _then)
      : super(_value, (v) => _then(v as _PlayOutState));

  @override
  _PlayOutState get _value => super._value as _PlayOutState;

  @override
  $Res call({
    Object commandedState = freezed,
    Object hlsMediaUrl = freezed,
    Object videoType = freezed,
    Object cookie = freezed,
    Object isPlaying = freezed,
    Object currentPos = freezed,
    Object currentPosForUi = freezed,
    Object totalDuration = freezed,
    Object controllerVisibility = freezed,
    Object isSeekBarDragging = freezed,
    Object fullScreen = freezed,
    Object isBuffering = freezed,
    Object videoPlayerState = freezed,
    Object lastControllerCommandHolder = freezed,
  }) {
    return _then(_PlayOutState(
      commandedState: commandedState == freezed
          ? _value.commandedState
          : commandedState as PlayerCommandedState,
      hlsMediaUrl:
          hlsMediaUrl == freezed ? _value.hlsMediaUrl : hlsMediaUrl as String,
      videoType:
          videoType == freezed ? _value.videoType : videoType as VideoType,
      cookie: cookie == freezed ? _value.cookie : cookie as String,
      isPlaying: isPlaying == freezed ? _value.isPlaying : isPlaying as bool,
      currentPos:
          currentPos == freezed ? _value.currentPos : currentPos as Duration,
      currentPosForUi: currentPosForUi == freezed
          ? _value.currentPosForUi
          : currentPosForUi as Duration,
      totalDuration: totalDuration == freezed
          ? _value.totalDuration
          : totalDuration as Duration,
      controllerVisibility: controllerVisibility == freezed
          ? _value.controllerVisibility
          : controllerVisibility as bool,
      isSeekBarDragging: isSeekBarDragging == freezed
          ? _value.isSeekBarDragging
          : isSeekBarDragging as bool,
      fullScreen:
          fullScreen == freezed ? _value.fullScreen : fullScreen as bool,
      isBuffering:
          isBuffering == freezed ? _value.isBuffering : isBuffering as bool,
      videoPlayerState: videoPlayerState == freezed
          ? _value.videoPlayerState
          : videoPlayerState as VideoPlayerState,
      lastControllerCommandHolder: lastControllerCommandHolder == freezed
          ? _value.lastControllerCommandHolder
          : lastControllerCommandHolder as LastControllerCommandHolder,
    ));
  }
}

@protected

/// @nodoc
class _$_PlayOutState extends _PlayOutState {
  const _$_PlayOutState(
      {@required this.commandedState,
      this.hlsMediaUrl,
      this.videoType,
      this.cookie,
      this.isPlaying = false,
      @nullable @protected this.currentPos,
      @nullable @protected this.currentPosForUi,
      @nullable @protected this.totalDuration,
      this.controllerVisibility = false,
      this.isSeekBarDragging = false,
      this.fullScreen = false,
      this.isBuffering = false,
      this.videoPlayerState = const VideoPlayerState.preInitialized(),
      this.lastControllerCommandHolder = const LastControllerCommandHolder()})
      : assert(commandedState != null),
        assert(isPlaying != null),
        assert(controllerVisibility != null),
        assert(isSeekBarDragging != null),
        assert(fullScreen != null),
        assert(isBuffering != null),
        assert(videoPlayerState != null),
        assert(lastControllerCommandHolder != null),
        super._();

  @override
  final PlayerCommandedState commandedState;
  @override
  final String hlsMediaUrl;
  @override
  final VideoType videoType;
  @override
  final String cookie;
  @JsonKey(defaultValue: false)
  @override
  final bool isPlaying;
  @override
  @nullable
  @protected
  final Duration currentPos;
  @override
  @nullable
  @protected
  final Duration currentPosForUi;
  @override
  @nullable
  @protected
  final Duration totalDuration;
  @JsonKey(defaultValue: false)
  @override
  final bool controllerVisibility;
  @JsonKey(defaultValue: false)
  @override
  final bool isSeekBarDragging;
  @JsonKey(defaultValue: false)
  @override
  final bool fullScreen;
  @JsonKey(defaultValue: false)
  @override
  final bool isBuffering;
  @JsonKey(defaultValue: const VideoPlayerState.preInitialized())
  @override
  final VideoPlayerState videoPlayerState;
  @JsonKey(defaultValue: const LastControllerCommandHolder())
  @override
  final LastControllerCommandHolder lastControllerCommandHolder;

  @override
  String toString() {
    return 'PlayOutState(commandedState: $commandedState, hlsMediaUrl: $hlsMediaUrl, videoType: $videoType, cookie: $cookie, isPlaying: $isPlaying, currentPos: $currentPos, currentPosForUi: $currentPosForUi, totalDuration: $totalDuration, controllerVisibility: $controllerVisibility, isSeekBarDragging: $isSeekBarDragging, fullScreen: $fullScreen, isBuffering: $isBuffering, videoPlayerState: $videoPlayerState, lastControllerCommandHolder: $lastControllerCommandHolder)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlayOutState &&
            (identical(other.commandedState, commandedState) ||
                const DeepCollectionEquality()
                    .equals(other.commandedState, commandedState)) &&
            (identical(other.hlsMediaUrl, hlsMediaUrl) ||
                const DeepCollectionEquality()
                    .equals(other.hlsMediaUrl, hlsMediaUrl)) &&
            (identical(other.videoType, videoType) ||
                const DeepCollectionEquality()
                    .equals(other.videoType, videoType)) &&
            (identical(other.cookie, cookie) ||
                const DeepCollectionEquality().equals(other.cookie, cookie)) &&
            (identical(other.isPlaying, isPlaying) ||
                const DeepCollectionEquality()
                    .equals(other.isPlaying, isPlaying)) &&
            (identical(other.currentPos, currentPos) ||
                const DeepCollectionEquality()
                    .equals(other.currentPos, currentPos)) &&
            (identical(other.currentPosForUi, currentPosForUi) ||
                const DeepCollectionEquality()
                    .equals(other.currentPosForUi, currentPosForUi)) &&
            (identical(other.totalDuration, totalDuration) ||
                const DeepCollectionEquality()
                    .equals(other.totalDuration, totalDuration)) &&
            (identical(other.controllerVisibility, controllerVisibility) ||
                const DeepCollectionEquality().equals(
                    other.controllerVisibility, controllerVisibility)) &&
            (identical(other.isSeekBarDragging, isSeekBarDragging) ||
                const DeepCollectionEquality()
                    .equals(other.isSeekBarDragging, isSeekBarDragging)) &&
            (identical(other.fullScreen, fullScreen) ||
                const DeepCollectionEquality()
                    .equals(other.fullScreen, fullScreen)) &&
            (identical(other.isBuffering, isBuffering) ||
                const DeepCollectionEquality()
                    .equals(other.isBuffering, isBuffering)) &&
            (identical(other.videoPlayerState, videoPlayerState) ||
                const DeepCollectionEquality()
                    .equals(other.videoPlayerState, videoPlayerState)) &&
            (identical(other.lastControllerCommandHolder,
                    lastControllerCommandHolder) ||
                const DeepCollectionEquality().equals(
                    other.lastControllerCommandHolder,
                    lastControllerCommandHolder)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(commandedState) ^
      const DeepCollectionEquality().hash(hlsMediaUrl) ^
      const DeepCollectionEquality().hash(videoType) ^
      const DeepCollectionEquality().hash(cookie) ^
      const DeepCollectionEquality().hash(isPlaying) ^
      const DeepCollectionEquality().hash(currentPos) ^
      const DeepCollectionEquality().hash(currentPosForUi) ^
      const DeepCollectionEquality().hash(totalDuration) ^
      const DeepCollectionEquality().hash(controllerVisibility) ^
      const DeepCollectionEquality().hash(isSeekBarDragging) ^
      const DeepCollectionEquality().hash(fullScreen) ^
      const DeepCollectionEquality().hash(isBuffering) ^
      const DeepCollectionEquality().hash(videoPlayerState) ^
      const DeepCollectionEquality().hash(lastControllerCommandHolder);

  @JsonKey(ignore: true)
  @override
  _$PlayOutStateCopyWith<_PlayOutState> get copyWith =>
      __$PlayOutStateCopyWithImpl<_PlayOutState>(this, _$identity);
}

abstract class _PlayOutState extends PlayOutState {
  const _PlayOutState._() : super._();
  const factory _PlayOutState(
          {@required PlayerCommandedState commandedState,
          String hlsMediaUrl,
          VideoType videoType,
          String cookie,
          bool isPlaying,
          @nullable @protected Duration currentPos,
          @nullable @protected Duration currentPosForUi,
          @nullable @protected Duration totalDuration,
          bool controllerVisibility,
          bool isSeekBarDragging,
          bool fullScreen,
          bool isBuffering,
          VideoPlayerState videoPlayerState,
          LastControllerCommandHolder lastControllerCommandHolder}) =
      _$_PlayOutState;

  @override
  PlayerCommandedState get commandedState;
  @override
  String get hlsMediaUrl;
  @override
  VideoType get videoType;
  @override
  String get cookie;
  @override
  bool get isPlaying;
  @override
  @nullable
  @protected
  Duration get currentPos;
  @override
  @nullable
  @protected
  Duration get currentPosForUi;
  @override
  @nullable
  @protected
  Duration get totalDuration;
  @override
  bool get controllerVisibility;
  @override
  bool get isSeekBarDragging;
  @override
  bool get fullScreen;
  @override
  bool get isBuffering;
  @override
  VideoPlayerState get videoPlayerState;
  @override
  LastControllerCommandHolder get lastControllerCommandHolder;
  @override
  @JsonKey(ignore: true)
  _$PlayOutStateCopyWith<_PlayOutState> get copyWith;
}

/// @nodoc
class _$PlayerCommandedStateTearOff {
  const _$PlayerCommandedStateTearOff();

// ignore: unused_element
  _PlayerCommandedStatePrePlay prePlay() {
    return const _PlayerCommandedStatePrePlay();
  }

// ignore: unused_element
  _PlayerCommandedStatePostPlay postPlay() {
    return const _PlayerCommandedStatePostPlay();
  }

// ignore: unused_element
  _PlayerCommandedStatePostError error(ErrorMsgCommon errMsg) {
    return _PlayerCommandedStatePostError(
      errMsg,
    );
  }

// ignore: unused_element
  _PlayerCommandedStateInitializing initializing() {
    return const _PlayerCommandedStateInitializing();
  }
}

/// @nodoc
// ignore: unused_element
const $PlayerCommandedState = _$PlayerCommandedStateTearOff();

/// @nodoc
mixin _$PlayerCommandedState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult prePlay(),
    @required TResult postPlay(),
    @required TResult error(ErrorMsgCommon errMsg),
    @required TResult initializing(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult prePlay(),
    TResult postPlay(),
    TResult error(ErrorMsgCommon errMsg),
    TResult initializing(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult prePlay(_PlayerCommandedStatePrePlay value),
    @required TResult postPlay(_PlayerCommandedStatePostPlay value),
    @required TResult error(_PlayerCommandedStatePostError value),
    @required TResult initializing(_PlayerCommandedStateInitializing value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult prePlay(_PlayerCommandedStatePrePlay value),
    TResult postPlay(_PlayerCommandedStatePostPlay value),
    TResult error(_PlayerCommandedStatePostError value),
    TResult initializing(_PlayerCommandedStateInitializing value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PlayerCommandedStateCopyWith<$Res> {
  factory $PlayerCommandedStateCopyWith(PlayerCommandedState value,
          $Res Function(PlayerCommandedState) then) =
      _$PlayerCommandedStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PlayerCommandedStateCopyWithImpl<$Res>
    implements $PlayerCommandedStateCopyWith<$Res> {
  _$PlayerCommandedStateCopyWithImpl(this._value, this._then);

  final PlayerCommandedState _value;
  // ignore: unused_field
  final $Res Function(PlayerCommandedState) _then;
}

/// @nodoc
abstract class _$PlayerCommandedStatePrePlayCopyWith<$Res> {
  factory _$PlayerCommandedStatePrePlayCopyWith(
          _PlayerCommandedStatePrePlay value,
          $Res Function(_PlayerCommandedStatePrePlay) then) =
      __$PlayerCommandedStatePrePlayCopyWithImpl<$Res>;
}

/// @nodoc
class __$PlayerCommandedStatePrePlayCopyWithImpl<$Res>
    extends _$PlayerCommandedStateCopyWithImpl<$Res>
    implements _$PlayerCommandedStatePrePlayCopyWith<$Res> {
  __$PlayerCommandedStatePrePlayCopyWithImpl(
      _PlayerCommandedStatePrePlay _value,
      $Res Function(_PlayerCommandedStatePrePlay) _then)
      : super(_value, (v) => _then(v as _PlayerCommandedStatePrePlay));

  @override
  _PlayerCommandedStatePrePlay get _value =>
      super._value as _PlayerCommandedStatePrePlay;
}

/// @nodoc
class _$_PlayerCommandedStatePrePlay implements _PlayerCommandedStatePrePlay {
  const _$_PlayerCommandedStatePrePlay();

  @override
  String toString() {
    return 'PlayerCommandedState.prePlay()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PlayerCommandedStatePrePlay);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult prePlay(),
    @required TResult postPlay(),
    @required TResult error(ErrorMsgCommon errMsg),
    @required TResult initializing(),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return prePlay();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult prePlay(),
    TResult postPlay(),
    TResult error(ErrorMsgCommon errMsg),
    TResult initializing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (prePlay != null) {
      return prePlay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult prePlay(_PlayerCommandedStatePrePlay value),
    @required TResult postPlay(_PlayerCommandedStatePostPlay value),
    @required TResult error(_PlayerCommandedStatePostError value),
    @required TResult initializing(_PlayerCommandedStateInitializing value),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return prePlay(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult prePlay(_PlayerCommandedStatePrePlay value),
    TResult postPlay(_PlayerCommandedStatePostPlay value),
    TResult error(_PlayerCommandedStatePostError value),
    TResult initializing(_PlayerCommandedStateInitializing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (prePlay != null) {
      return prePlay(this);
    }
    return orElse();
  }
}

abstract class _PlayerCommandedStatePrePlay implements PlayerCommandedState {
  const factory _PlayerCommandedStatePrePlay() = _$_PlayerCommandedStatePrePlay;
}

/// @nodoc
abstract class _$PlayerCommandedStatePostPlayCopyWith<$Res> {
  factory _$PlayerCommandedStatePostPlayCopyWith(
          _PlayerCommandedStatePostPlay value,
          $Res Function(_PlayerCommandedStatePostPlay) then) =
      __$PlayerCommandedStatePostPlayCopyWithImpl<$Res>;
}

/// @nodoc
class __$PlayerCommandedStatePostPlayCopyWithImpl<$Res>
    extends _$PlayerCommandedStateCopyWithImpl<$Res>
    implements _$PlayerCommandedStatePostPlayCopyWith<$Res> {
  __$PlayerCommandedStatePostPlayCopyWithImpl(
      _PlayerCommandedStatePostPlay _value,
      $Res Function(_PlayerCommandedStatePostPlay) _then)
      : super(_value, (v) => _then(v as _PlayerCommandedStatePostPlay));

  @override
  _PlayerCommandedStatePostPlay get _value =>
      super._value as _PlayerCommandedStatePostPlay;
}

/// @nodoc
class _$_PlayerCommandedStatePostPlay implements _PlayerCommandedStatePostPlay {
  const _$_PlayerCommandedStatePostPlay();

  @override
  String toString() {
    return 'PlayerCommandedState.postPlay()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PlayerCommandedStatePostPlay);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult prePlay(),
    @required TResult postPlay(),
    @required TResult error(ErrorMsgCommon errMsg),
    @required TResult initializing(),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return postPlay();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult prePlay(),
    TResult postPlay(),
    TResult error(ErrorMsgCommon errMsg),
    TResult initializing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (postPlay != null) {
      return postPlay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult prePlay(_PlayerCommandedStatePrePlay value),
    @required TResult postPlay(_PlayerCommandedStatePostPlay value),
    @required TResult error(_PlayerCommandedStatePostError value),
    @required TResult initializing(_PlayerCommandedStateInitializing value),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return postPlay(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult prePlay(_PlayerCommandedStatePrePlay value),
    TResult postPlay(_PlayerCommandedStatePostPlay value),
    TResult error(_PlayerCommandedStatePostError value),
    TResult initializing(_PlayerCommandedStateInitializing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (postPlay != null) {
      return postPlay(this);
    }
    return orElse();
  }
}

abstract class _PlayerCommandedStatePostPlay implements PlayerCommandedState {
  const factory _PlayerCommandedStatePostPlay() =
      _$_PlayerCommandedStatePostPlay;
}

/// @nodoc
abstract class _$PlayerCommandedStatePostErrorCopyWith<$Res> {
  factory _$PlayerCommandedStatePostErrorCopyWith(
          _PlayerCommandedStatePostError value,
          $Res Function(_PlayerCommandedStatePostError) then) =
      __$PlayerCommandedStatePostErrorCopyWithImpl<$Res>;
  $Res call({ErrorMsgCommon errMsg});

  $ErrorMsgCommonCopyWith<$Res> get errMsg;
}

/// @nodoc
class __$PlayerCommandedStatePostErrorCopyWithImpl<$Res>
    extends _$PlayerCommandedStateCopyWithImpl<$Res>
    implements _$PlayerCommandedStatePostErrorCopyWith<$Res> {
  __$PlayerCommandedStatePostErrorCopyWithImpl(
      _PlayerCommandedStatePostError _value,
      $Res Function(_PlayerCommandedStatePostError) _then)
      : super(_value, (v) => _then(v as _PlayerCommandedStatePostError));

  @override
  _PlayerCommandedStatePostError get _value =>
      super._value as _PlayerCommandedStatePostError;

  @override
  $Res call({
    Object errMsg = freezed,
  }) {
    return _then(_PlayerCommandedStatePostError(
      errMsg == freezed ? _value.errMsg : errMsg as ErrorMsgCommon,
    ));
  }

  @override
  $ErrorMsgCommonCopyWith<$Res> get errMsg {
    if (_value.errMsg == null) {
      return null;
    }
    return $ErrorMsgCommonCopyWith<$Res>(_value.errMsg, (value) {
      return _then(_value.copyWith(errMsg: value));
    });
  }
}

/// @nodoc
class _$_PlayerCommandedStatePostError
    implements _PlayerCommandedStatePostError {
  const _$_PlayerCommandedStatePostError(this.errMsg) : assert(errMsg != null);

  @override
  final ErrorMsgCommon errMsg;

  @override
  String toString() {
    return 'PlayerCommandedState.error(errMsg: $errMsg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlayerCommandedStatePostError &&
            (identical(other.errMsg, errMsg) ||
                const DeepCollectionEquality().equals(other.errMsg, errMsg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(errMsg);

  @JsonKey(ignore: true)
  @override
  _$PlayerCommandedStatePostErrorCopyWith<_PlayerCommandedStatePostError>
      get copyWith => __$PlayerCommandedStatePostErrorCopyWithImpl<
          _PlayerCommandedStatePostError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult prePlay(),
    @required TResult postPlay(),
    @required TResult error(ErrorMsgCommon errMsg),
    @required TResult initializing(),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return error(errMsg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult prePlay(),
    TResult postPlay(),
    TResult error(ErrorMsgCommon errMsg),
    TResult initializing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(errMsg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult prePlay(_PlayerCommandedStatePrePlay value),
    @required TResult postPlay(_PlayerCommandedStatePostPlay value),
    @required TResult error(_PlayerCommandedStatePostError value),
    @required TResult initializing(_PlayerCommandedStateInitializing value),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult prePlay(_PlayerCommandedStatePrePlay value),
    TResult postPlay(_PlayerCommandedStatePostPlay value),
    TResult error(_PlayerCommandedStatePostError value),
    TResult initializing(_PlayerCommandedStateInitializing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _PlayerCommandedStatePostError implements PlayerCommandedState {
  const factory _PlayerCommandedStatePostError(ErrorMsgCommon errMsg) =
      _$_PlayerCommandedStatePostError;

  ErrorMsgCommon get errMsg;
  @JsonKey(ignore: true)
  _$PlayerCommandedStatePostErrorCopyWith<_PlayerCommandedStatePostError>
      get copyWith;
}

/// @nodoc
abstract class _$PlayerCommandedStateInitializingCopyWith<$Res> {
  factory _$PlayerCommandedStateInitializingCopyWith(
          _PlayerCommandedStateInitializing value,
          $Res Function(_PlayerCommandedStateInitializing) then) =
      __$PlayerCommandedStateInitializingCopyWithImpl<$Res>;
}

/// @nodoc
class __$PlayerCommandedStateInitializingCopyWithImpl<$Res>
    extends _$PlayerCommandedStateCopyWithImpl<$Res>
    implements _$PlayerCommandedStateInitializingCopyWith<$Res> {
  __$PlayerCommandedStateInitializingCopyWithImpl(
      _PlayerCommandedStateInitializing _value,
      $Res Function(_PlayerCommandedStateInitializing) _then)
      : super(_value, (v) => _then(v as _PlayerCommandedStateInitializing));

  @override
  _PlayerCommandedStateInitializing get _value =>
      super._value as _PlayerCommandedStateInitializing;
}

/// @nodoc
class _$_PlayerCommandedStateInitializing
    implements _PlayerCommandedStateInitializing {
  const _$_PlayerCommandedStateInitializing();

  @override
  String toString() {
    return 'PlayerCommandedState.initializing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlayerCommandedStateInitializing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult prePlay(),
    @required TResult postPlay(),
    @required TResult error(ErrorMsgCommon errMsg),
    @required TResult initializing(),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return initializing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult prePlay(),
    TResult postPlay(),
    TResult error(ErrorMsgCommon errMsg),
    TResult initializing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initializing != null) {
      return initializing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult prePlay(_PlayerCommandedStatePrePlay value),
    @required TResult postPlay(_PlayerCommandedStatePostPlay value),
    @required TResult error(_PlayerCommandedStatePostError value),
    @required TResult initializing(_PlayerCommandedStateInitializing value),
  }) {
    assert(prePlay != null);
    assert(postPlay != null);
    assert(error != null);
    assert(initializing != null);
    return initializing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult prePlay(_PlayerCommandedStatePrePlay value),
    TResult postPlay(_PlayerCommandedStatePostPlay value),
    TResult error(_PlayerCommandedStatePostError value),
    TResult initializing(_PlayerCommandedStateInitializing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initializing != null) {
      return initializing(this);
    }
    return orElse();
  }
}

abstract class _PlayerCommandedStateInitializing
    implements PlayerCommandedState {
  const factory _PlayerCommandedStateInitializing() =
      _$_PlayerCommandedStateInitializing;
}

/// @nodoc
class _$PageSheetModelTearOff {
  const _$PageSheetModelTearOff();

// ignore: unused_element
  _PageSheetModelHidden hidden() {
    return const _PageSheetModelHidden();
  }

// ignore: unused_element
  _PageSheetModelHandouts handouts() {
    return const _PageSheetModelHandouts();
  }

// ignore: unused_element
  _PageSheetModelPricing pricing() {
    return const _PageSheetModelPricing();
  }

// ignore: unused_element
  _PageSheetModelComment comment() {
    return const _PageSheetModelComment();
  }
}

/// @nodoc
// ignore: unused_element
const $PageSheetModel = _$PageSheetModelTearOff();

/// @nodoc
mixin _$PageSheetModel {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult hidden(),
    @required TResult handouts(),
    @required TResult pricing(),
    @required TResult comment(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult hidden(),
    TResult handouts(),
    TResult pricing(),
    TResult comment(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult hidden(_PageSheetModelHidden value),
    @required TResult handouts(_PageSheetModelHandouts value),
    @required TResult pricing(_PageSheetModelPricing value),
    @required TResult comment(_PageSheetModelComment value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult hidden(_PageSheetModelHidden value),
    TResult handouts(_PageSheetModelHandouts value),
    TResult pricing(_PageSheetModelPricing value),
    TResult comment(_PageSheetModelComment value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PageSheetModelCopyWith<$Res> {
  factory $PageSheetModelCopyWith(
          PageSheetModel value, $Res Function(PageSheetModel) then) =
      _$PageSheetModelCopyWithImpl<$Res>;
}

/// @nodoc
class _$PageSheetModelCopyWithImpl<$Res>
    implements $PageSheetModelCopyWith<$Res> {
  _$PageSheetModelCopyWithImpl(this._value, this._then);

  final PageSheetModel _value;
  // ignore: unused_field
  final $Res Function(PageSheetModel) _then;
}

/// @nodoc
abstract class _$PageSheetModelHiddenCopyWith<$Res> {
  factory _$PageSheetModelHiddenCopyWith(_PageSheetModelHidden value,
          $Res Function(_PageSheetModelHidden) then) =
      __$PageSheetModelHiddenCopyWithImpl<$Res>;
}

/// @nodoc
class __$PageSheetModelHiddenCopyWithImpl<$Res>
    extends _$PageSheetModelCopyWithImpl<$Res>
    implements _$PageSheetModelHiddenCopyWith<$Res> {
  __$PageSheetModelHiddenCopyWithImpl(
      _PageSheetModelHidden _value, $Res Function(_PageSheetModelHidden) _then)
      : super(_value, (v) => _then(v as _PageSheetModelHidden));

  @override
  _PageSheetModelHidden get _value => super._value as _PageSheetModelHidden;
}

/// @nodoc
class _$_PageSheetModelHidden implements _PageSheetModelHidden {
  const _$_PageSheetModelHidden();

  @override
  String toString() {
    return 'PageSheetModel.hidden()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PageSheetModelHidden);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult hidden(),
    @required TResult handouts(),
    @required TResult pricing(),
    @required TResult comment(),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return hidden();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult hidden(),
    TResult handouts(),
    TResult pricing(),
    TResult comment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (hidden != null) {
      return hidden();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult hidden(_PageSheetModelHidden value),
    @required TResult handouts(_PageSheetModelHandouts value),
    @required TResult pricing(_PageSheetModelPricing value),
    @required TResult comment(_PageSheetModelComment value),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return hidden(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult hidden(_PageSheetModelHidden value),
    TResult handouts(_PageSheetModelHandouts value),
    TResult pricing(_PageSheetModelPricing value),
    TResult comment(_PageSheetModelComment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (hidden != null) {
      return hidden(this);
    }
    return orElse();
  }
}

abstract class _PageSheetModelHidden implements PageSheetModel {
  const factory _PageSheetModelHidden() = _$_PageSheetModelHidden;
}

/// @nodoc
abstract class _$PageSheetModelHandoutsCopyWith<$Res> {
  factory _$PageSheetModelHandoutsCopyWith(_PageSheetModelHandouts value,
          $Res Function(_PageSheetModelHandouts) then) =
      __$PageSheetModelHandoutsCopyWithImpl<$Res>;
}

/// @nodoc
class __$PageSheetModelHandoutsCopyWithImpl<$Res>
    extends _$PageSheetModelCopyWithImpl<$Res>
    implements _$PageSheetModelHandoutsCopyWith<$Res> {
  __$PageSheetModelHandoutsCopyWithImpl(_PageSheetModelHandouts _value,
      $Res Function(_PageSheetModelHandouts) _then)
      : super(_value, (v) => _then(v as _PageSheetModelHandouts));

  @override
  _PageSheetModelHandouts get _value => super._value as _PageSheetModelHandouts;
}

/// @nodoc
class _$_PageSheetModelHandouts implements _PageSheetModelHandouts {
  const _$_PageSheetModelHandouts();

  @override
  String toString() {
    return 'PageSheetModel.handouts()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PageSheetModelHandouts);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult hidden(),
    @required TResult handouts(),
    @required TResult pricing(),
    @required TResult comment(),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return handouts();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult hidden(),
    TResult handouts(),
    TResult pricing(),
    TResult comment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (handouts != null) {
      return handouts();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult hidden(_PageSheetModelHidden value),
    @required TResult handouts(_PageSheetModelHandouts value),
    @required TResult pricing(_PageSheetModelPricing value),
    @required TResult comment(_PageSheetModelComment value),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return handouts(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult hidden(_PageSheetModelHidden value),
    TResult handouts(_PageSheetModelHandouts value),
    TResult pricing(_PageSheetModelPricing value),
    TResult comment(_PageSheetModelComment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (handouts != null) {
      return handouts(this);
    }
    return orElse();
  }
}

abstract class _PageSheetModelHandouts implements PageSheetModel {
  const factory _PageSheetModelHandouts() = _$_PageSheetModelHandouts;
}

/// @nodoc
abstract class _$PageSheetModelPricingCopyWith<$Res> {
  factory _$PageSheetModelPricingCopyWith(_PageSheetModelPricing value,
          $Res Function(_PageSheetModelPricing) then) =
      __$PageSheetModelPricingCopyWithImpl<$Res>;
}

/// @nodoc
class __$PageSheetModelPricingCopyWithImpl<$Res>
    extends _$PageSheetModelCopyWithImpl<$Res>
    implements _$PageSheetModelPricingCopyWith<$Res> {
  __$PageSheetModelPricingCopyWithImpl(_PageSheetModelPricing _value,
      $Res Function(_PageSheetModelPricing) _then)
      : super(_value, (v) => _then(v as _PageSheetModelPricing));

  @override
  _PageSheetModelPricing get _value => super._value as _PageSheetModelPricing;
}

/// @nodoc
class _$_PageSheetModelPricing implements _PageSheetModelPricing {
  const _$_PageSheetModelPricing();

  @override
  String toString() {
    return 'PageSheetModel.pricing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PageSheetModelPricing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult hidden(),
    @required TResult handouts(),
    @required TResult pricing(),
    @required TResult comment(),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return pricing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult hidden(),
    TResult handouts(),
    TResult pricing(),
    TResult comment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (pricing != null) {
      return pricing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult hidden(_PageSheetModelHidden value),
    @required TResult handouts(_PageSheetModelHandouts value),
    @required TResult pricing(_PageSheetModelPricing value),
    @required TResult comment(_PageSheetModelComment value),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return pricing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult hidden(_PageSheetModelHidden value),
    TResult handouts(_PageSheetModelHandouts value),
    TResult pricing(_PageSheetModelPricing value),
    TResult comment(_PageSheetModelComment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (pricing != null) {
      return pricing(this);
    }
    return orElse();
  }
}

abstract class _PageSheetModelPricing implements PageSheetModel {
  const factory _PageSheetModelPricing() = _$_PageSheetModelPricing;
}

/// @nodoc
abstract class _$PageSheetModelCommentCopyWith<$Res> {
  factory _$PageSheetModelCommentCopyWith(_PageSheetModelComment value,
          $Res Function(_PageSheetModelComment) then) =
      __$PageSheetModelCommentCopyWithImpl<$Res>;
}

/// @nodoc
class __$PageSheetModelCommentCopyWithImpl<$Res>
    extends _$PageSheetModelCopyWithImpl<$Res>
    implements _$PageSheetModelCommentCopyWith<$Res> {
  __$PageSheetModelCommentCopyWithImpl(_PageSheetModelComment _value,
      $Res Function(_PageSheetModelComment) _then)
      : super(_value, (v) => _then(v as _PageSheetModelComment));

  @override
  _PageSheetModelComment get _value => super._value as _PageSheetModelComment;
}

/// @nodoc
class _$_PageSheetModelComment implements _PageSheetModelComment {
  const _$_PageSheetModelComment();

  @override
  String toString() {
    return 'PageSheetModel.comment()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PageSheetModelComment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult hidden(),
    @required TResult handouts(),
    @required TResult pricing(),
    @required TResult comment(),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return comment();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult hidden(),
    TResult handouts(),
    TResult pricing(),
    TResult comment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (comment != null) {
      return comment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult hidden(_PageSheetModelHidden value),
    @required TResult handouts(_PageSheetModelHandouts value),
    @required TResult pricing(_PageSheetModelPricing value),
    @required TResult comment(_PageSheetModelComment value),
  }) {
    assert(hidden != null);
    assert(handouts != null);
    assert(pricing != null);
    assert(comment != null);
    return comment(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult hidden(_PageSheetModelHidden value),
    TResult handouts(_PageSheetModelHandouts value),
    TResult pricing(_PageSheetModelPricing value),
    TResult comment(_PageSheetModelComment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (comment != null) {
      return comment(this);
    }
    return orElse();
  }
}

abstract class _PageSheetModelComment implements PageSheetModel {
  const factory _PageSheetModelComment() = _$_PageSheetModelComment;
}

/// @nodoc
class _$LastControllerCommandHolderTearOff {
  const _$LastControllerCommandHolderTearOff();

// ignore: unused_element
  _LastControllerCommandHolder call(
      {LastControllerCommand command = const LastControllerCommand.initial(),
      String commandKey = ''}) {
    return _LastControllerCommandHolder(
      command: command,
      commandKey: commandKey,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $LastControllerCommandHolder = _$LastControllerCommandHolderTearOff();

/// @nodoc
mixin _$LastControllerCommandHolder {
  LastControllerCommand get command;
  String get commandKey;

  @JsonKey(ignore: true)
  $LastControllerCommandHolderCopyWith<LastControllerCommandHolder>
      get copyWith;
}

/// @nodoc
abstract class $LastControllerCommandHolderCopyWith<$Res> {
  factory $LastControllerCommandHolderCopyWith(
          LastControllerCommandHolder value,
          $Res Function(LastControllerCommandHolder) then) =
      _$LastControllerCommandHolderCopyWithImpl<$Res>;
  $Res call({LastControllerCommand command, String commandKey});

  $LastControllerCommandCopyWith<$Res> get command;
}

/// @nodoc
class _$LastControllerCommandHolderCopyWithImpl<$Res>
    implements $LastControllerCommandHolderCopyWith<$Res> {
  _$LastControllerCommandHolderCopyWithImpl(this._value, this._then);

  final LastControllerCommandHolder _value;
  // ignore: unused_field
  final $Res Function(LastControllerCommandHolder) _then;

  @override
  $Res call({
    Object command = freezed,
    Object commandKey = freezed,
  }) {
    return _then(_value.copyWith(
      command: command == freezed
          ? _value.command
          : command as LastControllerCommand,
      commandKey:
          commandKey == freezed ? _value.commandKey : commandKey as String,
    ));
  }

  @override
  $LastControllerCommandCopyWith<$Res> get command {
    if (_value.command == null) {
      return null;
    }
    return $LastControllerCommandCopyWith<$Res>(_value.command, (value) {
      return _then(_value.copyWith(command: value));
    });
  }
}

/// @nodoc
abstract class _$LastControllerCommandHolderCopyWith<$Res>
    implements $LastControllerCommandHolderCopyWith<$Res> {
  factory _$LastControllerCommandHolderCopyWith(
          _LastControllerCommandHolder value,
          $Res Function(_LastControllerCommandHolder) then) =
      __$LastControllerCommandHolderCopyWithImpl<$Res>;
  @override
  $Res call({LastControllerCommand command, String commandKey});

  @override
  $LastControllerCommandCopyWith<$Res> get command;
}

/// @nodoc
class __$LastControllerCommandHolderCopyWithImpl<$Res>
    extends _$LastControllerCommandHolderCopyWithImpl<$Res>
    implements _$LastControllerCommandHolderCopyWith<$Res> {
  __$LastControllerCommandHolderCopyWithImpl(
      _LastControllerCommandHolder _value,
      $Res Function(_LastControllerCommandHolder) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandHolder));

  @override
  _LastControllerCommandHolder get _value =>
      super._value as _LastControllerCommandHolder;

  @override
  $Res call({
    Object command = freezed,
    Object commandKey = freezed,
  }) {
    return _then(_LastControllerCommandHolder(
      command: command == freezed
          ? _value.command
          : command as LastControllerCommand,
      commandKey:
          commandKey == freezed ? _value.commandKey : commandKey as String,
    ));
  }
}

@protected

/// @nodoc
class _$_LastControllerCommandHolder implements _LastControllerCommandHolder {
  const _$_LastControllerCommandHolder(
      {this.command = const LastControllerCommand.initial(),
      this.commandKey = ''})
      : assert(command != null),
        assert(commandKey != null);

  @JsonKey(defaultValue: const LastControllerCommand.initial())
  @override
  final LastControllerCommand command;
  @JsonKey(defaultValue: '')
  @override
  final String commandKey;

  @override
  String toString() {
    return 'LastControllerCommandHolder(command: $command, commandKey: $commandKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LastControllerCommandHolder &&
            (identical(other.command, command) ||
                const DeepCollectionEquality()
                    .equals(other.command, command)) &&
            (identical(other.commandKey, commandKey) ||
                const DeepCollectionEquality()
                    .equals(other.commandKey, commandKey)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(command) ^
      const DeepCollectionEquality().hash(commandKey);

  @JsonKey(ignore: true)
  @override
  _$LastControllerCommandHolderCopyWith<_LastControllerCommandHolder>
      get copyWith => __$LastControllerCommandHolderCopyWithImpl<
          _LastControllerCommandHolder>(this, _$identity);
}

abstract class _LastControllerCommandHolder
    implements LastControllerCommandHolder {
  const factory _LastControllerCommandHolder(
      {LastControllerCommand command,
      String commandKey}) = _$_LastControllerCommandHolder;

  @override
  LastControllerCommand get command;
  @override
  String get commandKey;
  @override
  @JsonKey(ignore: true)
  _$LastControllerCommandHolderCopyWith<_LastControllerCommandHolder>
      get copyWith;
}

/// @nodoc
class _$LastControllerCommandTearOff {
  const _$LastControllerCommandTearOff();

// ignore: unused_element
  _LastControllerCommandInitial initial() {
    return const _LastControllerCommandInitial();
  }

// ignore: unused_element
  _LastControllerCommandPlay play(Duration position) {
    return _LastControllerCommandPlay(
      position,
    );
  }

// ignore: unused_element
  _LastControllerCommandPause pause() {
    return const _LastControllerCommandPause();
  }

// ignore: unused_element
  _LastControllerCommandSeek seek(Duration diff) {
    return _LastControllerCommandSeek(
      diff,
    );
  }

// ignore: unused_element
  _LastControllerCommandSeekTo seekTo(Duration diff) {
    return _LastControllerCommandSeekTo(
      diff,
    );
  }

// ignore: unused_element
  _LastControllerCommandPlayOrPause playOrPause() {
    return const _LastControllerCommandPlayOrPause();
  }
}

/// @nodoc
// ignore: unused_element
const $LastControllerCommand = _$LastControllerCommandTearOff();

/// @nodoc
mixin _$LastControllerCommand {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $LastControllerCommandCopyWith<$Res> {
  factory $LastControllerCommandCopyWith(LastControllerCommand value,
          $Res Function(LastControllerCommand) then) =
      _$LastControllerCommandCopyWithImpl<$Res>;
}

/// @nodoc
class _$LastControllerCommandCopyWithImpl<$Res>
    implements $LastControllerCommandCopyWith<$Res> {
  _$LastControllerCommandCopyWithImpl(this._value, this._then);

  final LastControllerCommand _value;
  // ignore: unused_field
  final $Res Function(LastControllerCommand) _then;
}

/// @nodoc
abstract class _$LastControllerCommandInitialCopyWith<$Res> {
  factory _$LastControllerCommandInitialCopyWith(
          _LastControllerCommandInitial value,
          $Res Function(_LastControllerCommandInitial) then) =
      __$LastControllerCommandInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$LastControllerCommandInitialCopyWithImpl<$Res>
    extends _$LastControllerCommandCopyWithImpl<$Res>
    implements _$LastControllerCommandInitialCopyWith<$Res> {
  __$LastControllerCommandInitialCopyWithImpl(
      _LastControllerCommandInitial _value,
      $Res Function(_LastControllerCommandInitial) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandInitial));

  @override
  _LastControllerCommandInitial get _value =>
      super._value as _LastControllerCommandInitial;
}

/// @nodoc
class _$_LastControllerCommandInitial implements _LastControllerCommandInitial {
  const _$_LastControllerCommandInitial();

  @override
  String toString() {
    return 'LastControllerCommand.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LastControllerCommandInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _LastControllerCommandInitial implements LastControllerCommand {
  const factory _LastControllerCommandInitial() =
      _$_LastControllerCommandInitial;
}

/// @nodoc
abstract class _$LastControllerCommandPlayCopyWith<$Res> {
  factory _$LastControllerCommandPlayCopyWith(_LastControllerCommandPlay value,
          $Res Function(_LastControllerCommandPlay) then) =
      __$LastControllerCommandPlayCopyWithImpl<$Res>;
  $Res call({Duration position});
}

/// @nodoc
class __$LastControllerCommandPlayCopyWithImpl<$Res>
    extends _$LastControllerCommandCopyWithImpl<$Res>
    implements _$LastControllerCommandPlayCopyWith<$Res> {
  __$LastControllerCommandPlayCopyWithImpl(_LastControllerCommandPlay _value,
      $Res Function(_LastControllerCommandPlay) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandPlay));

  @override
  _LastControllerCommandPlay get _value =>
      super._value as _LastControllerCommandPlay;

  @override
  $Res call({
    Object position = freezed,
  }) {
    return _then(_LastControllerCommandPlay(
      position == freezed ? _value.position : position as Duration,
    ));
  }
}

/// @nodoc
class _$_LastControllerCommandPlay implements _LastControllerCommandPlay {
  const _$_LastControllerCommandPlay(this.position) : assert(position != null);

  @override
  final Duration position;

  @override
  String toString() {
    return 'LastControllerCommand.play(position: $position)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LastControllerCommandPlay &&
            (identical(other.position, position) ||
                const DeepCollectionEquality()
                    .equals(other.position, position)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(position);

  @JsonKey(ignore: true)
  @override
  _$LastControllerCommandPlayCopyWith<_LastControllerCommandPlay>
      get copyWith =>
          __$LastControllerCommandPlayCopyWithImpl<_LastControllerCommandPlay>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return play(position);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (play != null) {
      return play(position);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return play(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (play != null) {
      return play(this);
    }
    return orElse();
  }
}

abstract class _LastControllerCommandPlay implements LastControllerCommand {
  const factory _LastControllerCommandPlay(Duration position) =
      _$_LastControllerCommandPlay;

  Duration get position;
  @JsonKey(ignore: true)
  _$LastControllerCommandPlayCopyWith<_LastControllerCommandPlay> get copyWith;
}

/// @nodoc
abstract class _$LastControllerCommandPauseCopyWith<$Res> {
  factory _$LastControllerCommandPauseCopyWith(
          _LastControllerCommandPause value,
          $Res Function(_LastControllerCommandPause) then) =
      __$LastControllerCommandPauseCopyWithImpl<$Res>;
}

/// @nodoc
class __$LastControllerCommandPauseCopyWithImpl<$Res>
    extends _$LastControllerCommandCopyWithImpl<$Res>
    implements _$LastControllerCommandPauseCopyWith<$Res> {
  __$LastControllerCommandPauseCopyWithImpl(_LastControllerCommandPause _value,
      $Res Function(_LastControllerCommandPause) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandPause));

  @override
  _LastControllerCommandPause get _value =>
      super._value as _LastControllerCommandPause;
}

/// @nodoc
class _$_LastControllerCommandPause implements _LastControllerCommandPause {
  const _$_LastControllerCommandPause();

  @override
  String toString() {
    return 'LastControllerCommand.pause()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LastControllerCommandPause);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return pause();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (pause != null) {
      return pause();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return pause(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (pause != null) {
      return pause(this);
    }
    return orElse();
  }
}

abstract class _LastControllerCommandPause implements LastControllerCommand {
  const factory _LastControllerCommandPause() = _$_LastControllerCommandPause;
}

/// @nodoc
abstract class _$LastControllerCommandSeekCopyWith<$Res> {
  factory _$LastControllerCommandSeekCopyWith(_LastControllerCommandSeek value,
          $Res Function(_LastControllerCommandSeek) then) =
      __$LastControllerCommandSeekCopyWithImpl<$Res>;
  $Res call({Duration diff});
}

/// @nodoc
class __$LastControllerCommandSeekCopyWithImpl<$Res>
    extends _$LastControllerCommandCopyWithImpl<$Res>
    implements _$LastControllerCommandSeekCopyWith<$Res> {
  __$LastControllerCommandSeekCopyWithImpl(_LastControllerCommandSeek _value,
      $Res Function(_LastControllerCommandSeek) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandSeek));

  @override
  _LastControllerCommandSeek get _value =>
      super._value as _LastControllerCommandSeek;

  @override
  $Res call({
    Object diff = freezed,
  }) {
    return _then(_LastControllerCommandSeek(
      diff == freezed ? _value.diff : diff as Duration,
    ));
  }
}

/// @nodoc
class _$_LastControllerCommandSeek implements _LastControllerCommandSeek {
  const _$_LastControllerCommandSeek(this.diff) : assert(diff != null);

  @override
  final Duration diff;

  @override
  String toString() {
    return 'LastControllerCommand.seek(diff: $diff)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LastControllerCommandSeek &&
            (identical(other.diff, diff) ||
                const DeepCollectionEquality().equals(other.diff, diff)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(diff);

  @JsonKey(ignore: true)
  @override
  _$LastControllerCommandSeekCopyWith<_LastControllerCommandSeek>
      get copyWith =>
          __$LastControllerCommandSeekCopyWithImpl<_LastControllerCommandSeek>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return seek(diff);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (seek != null) {
      return seek(diff);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return seek(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (seek != null) {
      return seek(this);
    }
    return orElse();
  }
}

abstract class _LastControllerCommandSeek implements LastControllerCommand {
  const factory _LastControllerCommandSeek(Duration diff) =
      _$_LastControllerCommandSeek;

  Duration get diff;
  @JsonKey(ignore: true)
  _$LastControllerCommandSeekCopyWith<_LastControllerCommandSeek> get copyWith;
}

/// @nodoc
abstract class _$LastControllerCommandSeekToCopyWith<$Res> {
  factory _$LastControllerCommandSeekToCopyWith(
          _LastControllerCommandSeekTo value,
          $Res Function(_LastControllerCommandSeekTo) then) =
      __$LastControllerCommandSeekToCopyWithImpl<$Res>;
  $Res call({Duration diff});
}

/// @nodoc
class __$LastControllerCommandSeekToCopyWithImpl<$Res>
    extends _$LastControllerCommandCopyWithImpl<$Res>
    implements _$LastControllerCommandSeekToCopyWith<$Res> {
  __$LastControllerCommandSeekToCopyWithImpl(
      _LastControllerCommandSeekTo _value,
      $Res Function(_LastControllerCommandSeekTo) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandSeekTo));

  @override
  _LastControllerCommandSeekTo get _value =>
      super._value as _LastControllerCommandSeekTo;

  @override
  $Res call({
    Object diff = freezed,
  }) {
    return _then(_LastControllerCommandSeekTo(
      diff == freezed ? _value.diff : diff as Duration,
    ));
  }
}

/// @nodoc
class _$_LastControllerCommandSeekTo implements _LastControllerCommandSeekTo {
  const _$_LastControllerCommandSeekTo(this.diff) : assert(diff != null);

  @override
  final Duration diff;

  @override
  String toString() {
    return 'LastControllerCommand.seekTo(diff: $diff)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LastControllerCommandSeekTo &&
            (identical(other.diff, diff) ||
                const DeepCollectionEquality().equals(other.diff, diff)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(diff);

  @JsonKey(ignore: true)
  @override
  _$LastControllerCommandSeekToCopyWith<_LastControllerCommandSeekTo>
      get copyWith => __$LastControllerCommandSeekToCopyWithImpl<
          _LastControllerCommandSeekTo>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return seekTo(diff);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (seekTo != null) {
      return seekTo(diff);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return seekTo(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (seekTo != null) {
      return seekTo(this);
    }
    return orElse();
  }
}

abstract class _LastControllerCommandSeekTo implements LastControllerCommand {
  const factory _LastControllerCommandSeekTo(Duration diff) =
      _$_LastControllerCommandSeekTo;

  Duration get diff;
  @JsonKey(ignore: true)
  _$LastControllerCommandSeekToCopyWith<_LastControllerCommandSeekTo>
      get copyWith;
}

/// @nodoc
abstract class _$LastControllerCommandPlayOrPauseCopyWith<$Res> {
  factory _$LastControllerCommandPlayOrPauseCopyWith(
          _LastControllerCommandPlayOrPause value,
          $Res Function(_LastControllerCommandPlayOrPause) then) =
      __$LastControllerCommandPlayOrPauseCopyWithImpl<$Res>;
}

/// @nodoc
class __$LastControllerCommandPlayOrPauseCopyWithImpl<$Res>
    extends _$LastControllerCommandCopyWithImpl<$Res>
    implements _$LastControllerCommandPlayOrPauseCopyWith<$Res> {
  __$LastControllerCommandPlayOrPauseCopyWithImpl(
      _LastControllerCommandPlayOrPause _value,
      $Res Function(_LastControllerCommandPlayOrPause) _then)
      : super(_value, (v) => _then(v as _LastControllerCommandPlayOrPause));

  @override
  _LastControllerCommandPlayOrPause get _value =>
      super._value as _LastControllerCommandPlayOrPause;
}

/// @nodoc
class _$_LastControllerCommandPlayOrPause
    implements _LastControllerCommandPlayOrPause {
  const _$_LastControllerCommandPlayOrPause();

  @override
  String toString() {
    return 'LastControllerCommand.playOrPause()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LastControllerCommandPlayOrPause);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult seek(Duration diff),
    @required TResult seekTo(Duration diff),
    @required TResult playOrPause(),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return playOrPause();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult play(Duration position),
    TResult pause(),
    TResult seek(Duration diff),
    TResult seekTo(Duration diff),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (playOrPause != null) {
      return playOrPause();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_LastControllerCommandInitial value),
    @required TResult play(_LastControllerCommandPlay value),
    @required TResult pause(_LastControllerCommandPause value),
    @required TResult seek(_LastControllerCommandSeek value),
    @required TResult seekTo(_LastControllerCommandSeekTo value),
    @required TResult playOrPause(_LastControllerCommandPlayOrPause value),
  }) {
    assert(initial != null);
    assert(play != null);
    assert(pause != null);
    assert(seek != null);
    assert(seekTo != null);
    assert(playOrPause != null);
    return playOrPause(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_LastControllerCommandInitial value),
    TResult play(_LastControllerCommandPlay value),
    TResult pause(_LastControllerCommandPause value),
    TResult seek(_LastControllerCommandSeek value),
    TResult seekTo(_LastControllerCommandSeekTo value),
    TResult playOrPause(_LastControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (playOrPause != null) {
      return playOrPause(this);
    }
    return orElse();
  }
}

abstract class _LastControllerCommandPlayOrPause
    implements LastControllerCommand {
  const factory _LastControllerCommandPlayOrPause() =
      _$_LastControllerCommandPlayOrPause;
}

/// @nodoc
class _$VideoControllerCommandTearOff {
  const _$VideoControllerCommandTearOff();

// ignore: unused_element
  _VideoControllerCommandPlay play(Duration position) {
    return _VideoControllerCommandPlay(
      position,
    );
  }

// ignore: unused_element
  _VideoControllerCommandPause pause() {
    return const _VideoControllerCommandPause();
  }

// ignore: unused_element
  _VideoControllerCommandPlayOrPause playOrPause() {
    return const _VideoControllerCommandPlayOrPause();
  }
}

/// @nodoc
// ignore: unused_element
const $VideoControllerCommand = _$VideoControllerCommandTearOff();

/// @nodoc
mixin _$VideoControllerCommand {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult playOrPause(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult play(Duration position),
    TResult pause(),
    TResult playOrPause(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult play(_VideoControllerCommandPlay value),
    @required TResult pause(_VideoControllerCommandPause value),
    @required TResult playOrPause(_VideoControllerCommandPlayOrPause value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult play(_VideoControllerCommandPlay value),
    TResult pause(_VideoControllerCommandPause value),
    TResult playOrPause(_VideoControllerCommandPlayOrPause value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $VideoControllerCommandCopyWith<$Res> {
  factory $VideoControllerCommandCopyWith(VideoControllerCommand value,
          $Res Function(VideoControllerCommand) then) =
      _$VideoControllerCommandCopyWithImpl<$Res>;
}

/// @nodoc
class _$VideoControllerCommandCopyWithImpl<$Res>
    implements $VideoControllerCommandCopyWith<$Res> {
  _$VideoControllerCommandCopyWithImpl(this._value, this._then);

  final VideoControllerCommand _value;
  // ignore: unused_field
  final $Res Function(VideoControllerCommand) _then;
}

/// @nodoc
abstract class _$VideoControllerCommandPlayCopyWith<$Res> {
  factory _$VideoControllerCommandPlayCopyWith(
          _VideoControllerCommandPlay value,
          $Res Function(_VideoControllerCommandPlay) then) =
      __$VideoControllerCommandPlayCopyWithImpl<$Res>;
  $Res call({Duration position});
}

/// @nodoc
class __$VideoControllerCommandPlayCopyWithImpl<$Res>
    extends _$VideoControllerCommandCopyWithImpl<$Res>
    implements _$VideoControllerCommandPlayCopyWith<$Res> {
  __$VideoControllerCommandPlayCopyWithImpl(_VideoControllerCommandPlay _value,
      $Res Function(_VideoControllerCommandPlay) _then)
      : super(_value, (v) => _then(v as _VideoControllerCommandPlay));

  @override
  _VideoControllerCommandPlay get _value =>
      super._value as _VideoControllerCommandPlay;

  @override
  $Res call({
    Object position = freezed,
  }) {
    return _then(_VideoControllerCommandPlay(
      position == freezed ? _value.position : position as Duration,
    ));
  }
}

/// @nodoc
class _$_VideoControllerCommandPlay extends _VideoControllerCommandPlay {
  const _$_VideoControllerCommandPlay(this.position)
      : assert(position != null),
        super._();

  @override
  final Duration position;

  @override
  String toString() {
    return 'VideoControllerCommand.play(position: $position)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _VideoControllerCommandPlay &&
            (identical(other.position, position) ||
                const DeepCollectionEquality()
                    .equals(other.position, position)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(position);

  @JsonKey(ignore: true)
  @override
  _$VideoControllerCommandPlayCopyWith<_VideoControllerCommandPlay>
      get copyWith => __$VideoControllerCommandPlayCopyWithImpl<
          _VideoControllerCommandPlay>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult playOrPause(),
  }) {
    assert(play != null);
    assert(pause != null);
    assert(playOrPause != null);
    return play(position);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult play(Duration position),
    TResult pause(),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (play != null) {
      return play(position);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult play(_VideoControllerCommandPlay value),
    @required TResult pause(_VideoControllerCommandPause value),
    @required TResult playOrPause(_VideoControllerCommandPlayOrPause value),
  }) {
    assert(play != null);
    assert(pause != null);
    assert(playOrPause != null);
    return play(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult play(_VideoControllerCommandPlay value),
    TResult pause(_VideoControllerCommandPause value),
    TResult playOrPause(_VideoControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (play != null) {
      return play(this);
    }
    return orElse();
  }
}

abstract class _VideoControllerCommandPlay extends VideoControllerCommand {
  const _VideoControllerCommandPlay._() : super._();
  const factory _VideoControllerCommandPlay(Duration position) =
      _$_VideoControllerCommandPlay;

  Duration get position;
  @JsonKey(ignore: true)
  _$VideoControllerCommandPlayCopyWith<_VideoControllerCommandPlay>
      get copyWith;
}

/// @nodoc
abstract class _$VideoControllerCommandPauseCopyWith<$Res> {
  factory _$VideoControllerCommandPauseCopyWith(
          _VideoControllerCommandPause value,
          $Res Function(_VideoControllerCommandPause) then) =
      __$VideoControllerCommandPauseCopyWithImpl<$Res>;
}

/// @nodoc
class __$VideoControllerCommandPauseCopyWithImpl<$Res>
    extends _$VideoControllerCommandCopyWithImpl<$Res>
    implements _$VideoControllerCommandPauseCopyWith<$Res> {
  __$VideoControllerCommandPauseCopyWithImpl(
      _VideoControllerCommandPause _value,
      $Res Function(_VideoControllerCommandPause) _then)
      : super(_value, (v) => _then(v as _VideoControllerCommandPause));

  @override
  _VideoControllerCommandPause get _value =>
      super._value as _VideoControllerCommandPause;
}

/// @nodoc
class _$_VideoControllerCommandPause extends _VideoControllerCommandPause {
  const _$_VideoControllerCommandPause() : super._();

  @override
  String toString() {
    return 'VideoControllerCommand.pause()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VideoControllerCommandPause);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult playOrPause(),
  }) {
    assert(play != null);
    assert(pause != null);
    assert(playOrPause != null);
    return pause();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult play(Duration position),
    TResult pause(),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (pause != null) {
      return pause();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult play(_VideoControllerCommandPlay value),
    @required TResult pause(_VideoControllerCommandPause value),
    @required TResult playOrPause(_VideoControllerCommandPlayOrPause value),
  }) {
    assert(play != null);
    assert(pause != null);
    assert(playOrPause != null);
    return pause(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult play(_VideoControllerCommandPlay value),
    TResult pause(_VideoControllerCommandPause value),
    TResult playOrPause(_VideoControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (pause != null) {
      return pause(this);
    }
    return orElse();
  }
}

abstract class _VideoControllerCommandPause extends VideoControllerCommand {
  const _VideoControllerCommandPause._() : super._();
  const factory _VideoControllerCommandPause() = _$_VideoControllerCommandPause;
}

/// @nodoc
abstract class _$VideoControllerCommandPlayOrPauseCopyWith<$Res> {
  factory _$VideoControllerCommandPlayOrPauseCopyWith(
          _VideoControllerCommandPlayOrPause value,
          $Res Function(_VideoControllerCommandPlayOrPause) then) =
      __$VideoControllerCommandPlayOrPauseCopyWithImpl<$Res>;
}

/// @nodoc
class __$VideoControllerCommandPlayOrPauseCopyWithImpl<$Res>
    extends _$VideoControllerCommandCopyWithImpl<$Res>
    implements _$VideoControllerCommandPlayOrPauseCopyWith<$Res> {
  __$VideoControllerCommandPlayOrPauseCopyWithImpl(
      _VideoControllerCommandPlayOrPause _value,
      $Res Function(_VideoControllerCommandPlayOrPause) _then)
      : super(_value, (v) => _then(v as _VideoControllerCommandPlayOrPause));

  @override
  _VideoControllerCommandPlayOrPause get _value =>
      super._value as _VideoControllerCommandPlayOrPause;
}

/// @nodoc
class _$_VideoControllerCommandPlayOrPause
    extends _VideoControllerCommandPlayOrPause {
  const _$_VideoControllerCommandPlayOrPause() : super._();

  @override
  String toString() {
    return 'VideoControllerCommand.playOrPause()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _VideoControllerCommandPlayOrPause);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult play(Duration position),
    @required TResult pause(),
    @required TResult playOrPause(),
  }) {
    assert(play != null);
    assert(pause != null);
    assert(playOrPause != null);
    return playOrPause();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult play(Duration position),
    TResult pause(),
    TResult playOrPause(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (playOrPause != null) {
      return playOrPause();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult play(_VideoControllerCommandPlay value),
    @required TResult pause(_VideoControllerCommandPause value),
    @required TResult playOrPause(_VideoControllerCommandPlayOrPause value),
  }) {
    assert(play != null);
    assert(pause != null);
    assert(playOrPause != null);
    return playOrPause(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult play(_VideoControllerCommandPlay value),
    TResult pause(_VideoControllerCommandPause value),
    TResult playOrPause(_VideoControllerCommandPlayOrPause value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (playOrPause != null) {
      return playOrPause(this);
    }
    return orElse();
  }
}

abstract class _VideoControllerCommandPlayOrPause
    extends VideoControllerCommand {
  const _VideoControllerCommandPlayOrPause._() : super._();
  const factory _VideoControllerCommandPlayOrPause() =
      _$_VideoControllerCommandPlayOrPause;
}

/// @nodoc
class _$VideoPlayerStateTearOff {
  const _$VideoPlayerStateTearOff();

// ignore: unused_element
  _VideoPlayerStatePreInitialized preInitialized() {
    return const _VideoPlayerStatePreInitialized();
  }

// ignore: unused_element
  _VideoPlayerStateReady ready() {
    return const _VideoPlayerStateReady();
  }

// ignore: unused_element
  _VideoPlayerStateError error(String msg) {
    return _VideoPlayerStateError(
      msg,
    );
  }

// ignore: unused_element
  _VideoPlayerStateFinish finish() {
    return const _VideoPlayerStateFinish();
  }
}

/// @nodoc
// ignore: unused_element
const $VideoPlayerState = _$VideoPlayerStateTearOff();

/// @nodoc
mixin _$VideoPlayerState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult ready(),
    @required TResult error(String msg),
    @required TResult finish(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult ready(),
    TResult error(String msg),
    TResult finish(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_VideoPlayerStatePreInitialized value),
    @required TResult ready(_VideoPlayerStateReady value),
    @required TResult error(_VideoPlayerStateError value),
    @required TResult finish(_VideoPlayerStateFinish value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_VideoPlayerStatePreInitialized value),
    TResult ready(_VideoPlayerStateReady value),
    TResult error(_VideoPlayerStateError value),
    TResult finish(_VideoPlayerStateFinish value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $VideoPlayerStateCopyWith<$Res> {
  factory $VideoPlayerStateCopyWith(
          VideoPlayerState value, $Res Function(VideoPlayerState) then) =
      _$VideoPlayerStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$VideoPlayerStateCopyWithImpl<$Res>
    implements $VideoPlayerStateCopyWith<$Res> {
  _$VideoPlayerStateCopyWithImpl(this._value, this._then);

  final VideoPlayerState _value;
  // ignore: unused_field
  final $Res Function(VideoPlayerState) _then;
}

/// @nodoc
abstract class _$VideoPlayerStatePreInitializedCopyWith<$Res> {
  factory _$VideoPlayerStatePreInitializedCopyWith(
          _VideoPlayerStatePreInitialized value,
          $Res Function(_VideoPlayerStatePreInitialized) then) =
      __$VideoPlayerStatePreInitializedCopyWithImpl<$Res>;
}

/// @nodoc
class __$VideoPlayerStatePreInitializedCopyWithImpl<$Res>
    extends _$VideoPlayerStateCopyWithImpl<$Res>
    implements _$VideoPlayerStatePreInitializedCopyWith<$Res> {
  __$VideoPlayerStatePreInitializedCopyWithImpl(
      _VideoPlayerStatePreInitialized _value,
      $Res Function(_VideoPlayerStatePreInitialized) _then)
      : super(_value, (v) => _then(v as _VideoPlayerStatePreInitialized));

  @override
  _VideoPlayerStatePreInitialized get _value =>
      super._value as _VideoPlayerStatePreInitialized;
}

/// @nodoc
class _$_VideoPlayerStatePreInitialized
    implements _VideoPlayerStatePreInitialized {
  const _$_VideoPlayerStatePreInitialized();

  @override
  String toString() {
    return 'VideoPlayerState.preInitialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VideoPlayerStatePreInitialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult ready(),
    @required TResult error(String msg),
    @required TResult finish(),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return preInitialized();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult ready(),
    TResult error(String msg),
    TResult finish(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (preInitialized != null) {
      return preInitialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_VideoPlayerStatePreInitialized value),
    @required TResult ready(_VideoPlayerStateReady value),
    @required TResult error(_VideoPlayerStateError value),
    @required TResult finish(_VideoPlayerStateFinish value),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return preInitialized(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_VideoPlayerStatePreInitialized value),
    TResult ready(_VideoPlayerStateReady value),
    TResult error(_VideoPlayerStateError value),
    TResult finish(_VideoPlayerStateFinish value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (preInitialized != null) {
      return preInitialized(this);
    }
    return orElse();
  }
}

abstract class _VideoPlayerStatePreInitialized implements VideoPlayerState {
  const factory _VideoPlayerStatePreInitialized() =
      _$_VideoPlayerStatePreInitialized;
}

/// @nodoc
abstract class _$VideoPlayerStateReadyCopyWith<$Res> {
  factory _$VideoPlayerStateReadyCopyWith(_VideoPlayerStateReady value,
          $Res Function(_VideoPlayerStateReady) then) =
      __$VideoPlayerStateReadyCopyWithImpl<$Res>;
}

/// @nodoc
class __$VideoPlayerStateReadyCopyWithImpl<$Res>
    extends _$VideoPlayerStateCopyWithImpl<$Res>
    implements _$VideoPlayerStateReadyCopyWith<$Res> {
  __$VideoPlayerStateReadyCopyWithImpl(_VideoPlayerStateReady _value,
      $Res Function(_VideoPlayerStateReady) _then)
      : super(_value, (v) => _then(v as _VideoPlayerStateReady));

  @override
  _VideoPlayerStateReady get _value => super._value as _VideoPlayerStateReady;
}

/// @nodoc
class _$_VideoPlayerStateReady implements _VideoPlayerStateReady {
  const _$_VideoPlayerStateReady();

  @override
  String toString() {
    return 'VideoPlayerState.ready()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VideoPlayerStateReady);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult ready(),
    @required TResult error(String msg),
    @required TResult finish(),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return ready();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult ready(),
    TResult error(String msg),
    TResult finish(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (ready != null) {
      return ready();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_VideoPlayerStatePreInitialized value),
    @required TResult ready(_VideoPlayerStateReady value),
    @required TResult error(_VideoPlayerStateError value),
    @required TResult finish(_VideoPlayerStateFinish value),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return ready(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_VideoPlayerStatePreInitialized value),
    TResult ready(_VideoPlayerStateReady value),
    TResult error(_VideoPlayerStateError value),
    TResult finish(_VideoPlayerStateFinish value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (ready != null) {
      return ready(this);
    }
    return orElse();
  }
}

abstract class _VideoPlayerStateReady implements VideoPlayerState {
  const factory _VideoPlayerStateReady() = _$_VideoPlayerStateReady;
}

/// @nodoc
abstract class _$VideoPlayerStateErrorCopyWith<$Res> {
  factory _$VideoPlayerStateErrorCopyWith(_VideoPlayerStateError value,
          $Res Function(_VideoPlayerStateError) then) =
      __$VideoPlayerStateErrorCopyWithImpl<$Res>;
  $Res call({String msg});
}

/// @nodoc
class __$VideoPlayerStateErrorCopyWithImpl<$Res>
    extends _$VideoPlayerStateCopyWithImpl<$Res>
    implements _$VideoPlayerStateErrorCopyWith<$Res> {
  __$VideoPlayerStateErrorCopyWithImpl(_VideoPlayerStateError _value,
      $Res Function(_VideoPlayerStateError) _then)
      : super(_value, (v) => _then(v as _VideoPlayerStateError));

  @override
  _VideoPlayerStateError get _value => super._value as _VideoPlayerStateError;

  @override
  $Res call({
    Object msg = freezed,
  }) {
    return _then(_VideoPlayerStateError(
      msg == freezed ? _value.msg : msg as String,
    ));
  }
}

/// @nodoc
class _$_VideoPlayerStateError implements _VideoPlayerStateError {
  const _$_VideoPlayerStateError(this.msg) : assert(msg != null);

  @override
  final String msg;

  @override
  String toString() {
    return 'VideoPlayerState.error(msg: $msg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _VideoPlayerStateError &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(msg);

  @JsonKey(ignore: true)
  @override
  _$VideoPlayerStateErrorCopyWith<_VideoPlayerStateError> get copyWith =>
      __$VideoPlayerStateErrorCopyWithImpl<_VideoPlayerStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult ready(),
    @required TResult error(String msg),
    @required TResult finish(),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return error(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult ready(),
    TResult error(String msg),
    TResult finish(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_VideoPlayerStatePreInitialized value),
    @required TResult ready(_VideoPlayerStateReady value),
    @required TResult error(_VideoPlayerStateError value),
    @required TResult finish(_VideoPlayerStateFinish value),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_VideoPlayerStatePreInitialized value),
    TResult ready(_VideoPlayerStateReady value),
    TResult error(_VideoPlayerStateError value),
    TResult finish(_VideoPlayerStateFinish value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _VideoPlayerStateError implements VideoPlayerState {
  const factory _VideoPlayerStateError(String msg) = _$_VideoPlayerStateError;

  String get msg;
  @JsonKey(ignore: true)
  _$VideoPlayerStateErrorCopyWith<_VideoPlayerStateError> get copyWith;
}

/// @nodoc
abstract class _$VideoPlayerStateFinishCopyWith<$Res> {
  factory _$VideoPlayerStateFinishCopyWith(_VideoPlayerStateFinish value,
          $Res Function(_VideoPlayerStateFinish) then) =
      __$VideoPlayerStateFinishCopyWithImpl<$Res>;
}

/// @nodoc
class __$VideoPlayerStateFinishCopyWithImpl<$Res>
    extends _$VideoPlayerStateCopyWithImpl<$Res>
    implements _$VideoPlayerStateFinishCopyWith<$Res> {
  __$VideoPlayerStateFinishCopyWithImpl(_VideoPlayerStateFinish _value,
      $Res Function(_VideoPlayerStateFinish) _then)
      : super(_value, (v) => _then(v as _VideoPlayerStateFinish));

  @override
  _VideoPlayerStateFinish get _value => super._value as _VideoPlayerStateFinish;
}

/// @nodoc
class _$_VideoPlayerStateFinish implements _VideoPlayerStateFinish {
  const _$_VideoPlayerStateFinish();

  @override
  String toString() {
    return 'VideoPlayerState.finish()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VideoPlayerStateFinish);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult preInitialized(),
    @required TResult ready(),
    @required TResult error(String msg),
    @required TResult finish(),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return finish();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult preInitialized(),
    TResult ready(),
    TResult error(String msg),
    TResult finish(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (finish != null) {
      return finish();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult preInitialized(_VideoPlayerStatePreInitialized value),
    @required TResult ready(_VideoPlayerStateReady value),
    @required TResult error(_VideoPlayerStateError value),
    @required TResult finish(_VideoPlayerStateFinish value),
  }) {
    assert(preInitialized != null);
    assert(ready != null);
    assert(error != null);
    assert(finish != null);
    return finish(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult preInitialized(_VideoPlayerStatePreInitialized value),
    TResult ready(_VideoPlayerStateReady value),
    TResult error(_VideoPlayerStateError value),
    TResult finish(_VideoPlayerStateFinish value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (finish != null) {
      return finish(this);
    }
    return orElse();
  }
}

abstract class _VideoPlayerStateFinish implements VideoPlayerState {
  const factory _VideoPlayerStateFinish() = _$_VideoPlayerStateFinish;
}

/// @nodoc
class _$CommentsHolderTearOff {
  const _$CommentsHolderTearOff();

// ignore: unused_element
  _CommentsHolder call(
      {@required
      @Deprecated('use [_commentSorted]')
          List<CommentItem> comments,
      @required
          String pageNationKey,
      @required
          bool loadedMostPastComment,
      @required
          bool isRenewing,
      @required
          bool loadedMostFutureComment,
      @required
          CommentsState state,
      @required
          FollowTimeLineMode followTimeLineMode,
      @required
      @Deprecated('use [userPostedComment]')
          List<CommentItem> rawUserPostedComment}) {
    return _CommentsHolder(
      comments: comments,
      pageNationKey: pageNationKey,
      loadedMostPastComment: loadedMostPastComment,
      isRenewing: isRenewing,
      loadedMostFutureComment: loadedMostFutureComment,
      state: state,
      followTimeLineMode: followTimeLineMode,
      rawUserPostedComment: rawUserPostedComment,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $CommentsHolder = _$CommentsHolderTearOff();

/// @nodoc
mixin _$CommentsHolder {
  /// use [_commentSorted]
  @Deprecated('use [_commentSorted]')
  List<CommentItem> get comments;
  String get pageNationKey;
  bool get loadedMostPastComment;
  bool get isRenewing;
  bool get loadedMostFutureComment;
  CommentsState get state;
  FollowTimeLineMode get followTimeLineMode;

  /// use [userPostedComment]
  @Deprecated('use [userPostedComment]')
  List<CommentItem> get rawUserPostedComment;

  @JsonKey(ignore: true)
  $CommentsHolderCopyWith<CommentsHolder> get copyWith;
}

/// @nodoc
abstract class $CommentsHolderCopyWith<$Res> {
  factory $CommentsHolderCopyWith(
          CommentsHolder value, $Res Function(CommentsHolder) then) =
      _$CommentsHolderCopyWithImpl<$Res>;
  $Res call(
      {@Deprecated('use [_commentSorted]')
          List<CommentItem> comments,
      String pageNationKey,
      bool loadedMostPastComment,
      bool isRenewing,
      bool loadedMostFutureComment,
      CommentsState state,
      FollowTimeLineMode followTimeLineMode,
      @Deprecated('use [userPostedComment]')
          List<CommentItem> rawUserPostedComment});

  $CommentsStateCopyWith<$Res> get state;
  $FollowTimeLineModeCopyWith<$Res> get followTimeLineMode;
}

/// @nodoc
class _$CommentsHolderCopyWithImpl<$Res>
    implements $CommentsHolderCopyWith<$Res> {
  _$CommentsHolderCopyWithImpl(this._value, this._then);

  final CommentsHolder _value;
  // ignore: unused_field
  final $Res Function(CommentsHolder) _then;

  @override
  $Res call({
    Object comments = freezed,
    Object pageNationKey = freezed,
    Object loadedMostPastComment = freezed,
    Object isRenewing = freezed,
    Object loadedMostFutureComment = freezed,
    Object state = freezed,
    Object followTimeLineMode = freezed,
    Object rawUserPostedComment = freezed,
  }) {
    return _then(_value.copyWith(
      comments:
          comments == freezed ? _value.comments : comments as List<CommentItem>,
      pageNationKey: pageNationKey == freezed
          ? _value.pageNationKey
          : pageNationKey as String,
      loadedMostPastComment: loadedMostPastComment == freezed
          ? _value.loadedMostPastComment
          : loadedMostPastComment as bool,
      isRenewing:
          isRenewing == freezed ? _value.isRenewing : isRenewing as bool,
      loadedMostFutureComment: loadedMostFutureComment == freezed
          ? _value.loadedMostFutureComment
          : loadedMostFutureComment as bool,
      state: state == freezed ? _value.state : state as CommentsState,
      followTimeLineMode: followTimeLineMode == freezed
          ? _value.followTimeLineMode
          : followTimeLineMode as FollowTimeLineMode,
      rawUserPostedComment: rawUserPostedComment == freezed
          ? _value.rawUserPostedComment
          : rawUserPostedComment as List<CommentItem>,
    ));
  }

  @override
  $CommentsStateCopyWith<$Res> get state {
    if (_value.state == null) {
      return null;
    }
    return $CommentsStateCopyWith<$Res>(_value.state, (value) {
      return _then(_value.copyWith(state: value));
    });
  }

  @override
  $FollowTimeLineModeCopyWith<$Res> get followTimeLineMode {
    if (_value.followTimeLineMode == null) {
      return null;
    }
    return $FollowTimeLineModeCopyWith<$Res>(_value.followTimeLineMode,
        (value) {
      return _then(_value.copyWith(followTimeLineMode: value));
    });
  }
}

/// @nodoc
abstract class _$CommentsHolderCopyWith<$Res>
    implements $CommentsHolderCopyWith<$Res> {
  factory _$CommentsHolderCopyWith(
          _CommentsHolder value, $Res Function(_CommentsHolder) then) =
      __$CommentsHolderCopyWithImpl<$Res>;
  @override
  $Res call(
      {@Deprecated('use [_commentSorted]')
          List<CommentItem> comments,
      String pageNationKey,
      bool loadedMostPastComment,
      bool isRenewing,
      bool loadedMostFutureComment,
      CommentsState state,
      FollowTimeLineMode followTimeLineMode,
      @Deprecated('use [userPostedComment]')
          List<CommentItem> rawUserPostedComment});

  @override
  $CommentsStateCopyWith<$Res> get state;
  @override
  $FollowTimeLineModeCopyWith<$Res> get followTimeLineMode;
}

/// @nodoc
class __$CommentsHolderCopyWithImpl<$Res>
    extends _$CommentsHolderCopyWithImpl<$Res>
    implements _$CommentsHolderCopyWith<$Res> {
  __$CommentsHolderCopyWithImpl(
      _CommentsHolder _value, $Res Function(_CommentsHolder) _then)
      : super(_value, (v) => _then(v as _CommentsHolder));

  @override
  _CommentsHolder get _value => super._value as _CommentsHolder;

  @override
  $Res call({
    Object comments = freezed,
    Object pageNationKey = freezed,
    Object loadedMostPastComment = freezed,
    Object isRenewing = freezed,
    Object loadedMostFutureComment = freezed,
    Object state = freezed,
    Object followTimeLineMode = freezed,
    Object rawUserPostedComment = freezed,
  }) {
    return _then(_CommentsHolder(
      comments:
          comments == freezed ? _value.comments : comments as List<CommentItem>,
      pageNationKey: pageNationKey == freezed
          ? _value.pageNationKey
          : pageNationKey as String,
      loadedMostPastComment: loadedMostPastComment == freezed
          ? _value.loadedMostPastComment
          : loadedMostPastComment as bool,
      isRenewing:
          isRenewing == freezed ? _value.isRenewing : isRenewing as bool,
      loadedMostFutureComment: loadedMostFutureComment == freezed
          ? _value.loadedMostFutureComment
          : loadedMostFutureComment as bool,
      state: state == freezed ? _value.state : state as CommentsState,
      followTimeLineMode: followTimeLineMode == freezed
          ? _value.followTimeLineMode
          : followTimeLineMode as FollowTimeLineMode,
      rawUserPostedComment: rawUserPostedComment == freezed
          ? _value.rawUserPostedComment
          : rawUserPostedComment as List<CommentItem>,
    ));
  }
}

@protected

/// @nodoc
class _$_CommentsHolder extends _CommentsHolder {
  const _$_CommentsHolder(
      {@required
      @Deprecated('use [_commentSorted]')
          this.comments,
      @required
          this.pageNationKey,
      @required
          this.loadedMostPastComment,
      @required
          this.isRenewing,
      @required
          this.loadedMostFutureComment,
      @required
          this.state,
      @required
          this.followTimeLineMode,
      @required
      @Deprecated('use [userPostedComment]')
          this.rawUserPostedComment})
      : assert(comments != null),
        assert(pageNationKey != null),
        assert(loadedMostPastComment != null),
        assert(isRenewing != null),
        assert(loadedMostFutureComment != null),
        assert(state != null),
        assert(followTimeLineMode != null),
        assert(rawUserPostedComment != null),
        super._();

  @override

  /// use [_commentSorted]
  @Deprecated('use [_commentSorted]')
  final List<CommentItem> comments;
  @override
  final String pageNationKey;
  @override
  final bool loadedMostPastComment;
  @override
  final bool isRenewing;
  @override
  final bool loadedMostFutureComment;
  @override
  final CommentsState state;
  @override
  final FollowTimeLineMode followTimeLineMode;
  @override

  /// use [userPostedComment]
  @Deprecated('use [userPostedComment]')
  final List<CommentItem> rawUserPostedComment;

  @override
  String toString() {
    return 'CommentsHolder(comments: $comments, pageNationKey: $pageNationKey, loadedMostPastComment: $loadedMostPastComment, isRenewing: $isRenewing, loadedMostFutureComment: $loadedMostFutureComment, state: $state, followTimeLineMode: $followTimeLineMode, rawUserPostedComment: $rawUserPostedComment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CommentsHolder &&
            (identical(other.comments, comments) ||
                const DeepCollectionEquality()
                    .equals(other.comments, comments)) &&
            (identical(other.pageNationKey, pageNationKey) ||
                const DeepCollectionEquality()
                    .equals(other.pageNationKey, pageNationKey)) &&
            (identical(other.loadedMostPastComment, loadedMostPastComment) ||
                const DeepCollectionEquality().equals(
                    other.loadedMostPastComment, loadedMostPastComment)) &&
            (identical(other.isRenewing, isRenewing) ||
                const DeepCollectionEquality()
                    .equals(other.isRenewing, isRenewing)) &&
            (identical(
                    other.loadedMostFutureComment, loadedMostFutureComment) ||
                const DeepCollectionEquality().equals(
                    other.loadedMostFutureComment, loadedMostFutureComment)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.followTimeLineMode, followTimeLineMode) ||
                const DeepCollectionEquality()
                    .equals(other.followTimeLineMode, followTimeLineMode)) &&
            (identical(other.rawUserPostedComment, rawUserPostedComment) ||
                const DeepCollectionEquality()
                    .equals(other.rawUserPostedComment, rawUserPostedComment)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(comments) ^
      const DeepCollectionEquality().hash(pageNationKey) ^
      const DeepCollectionEquality().hash(loadedMostPastComment) ^
      const DeepCollectionEquality().hash(isRenewing) ^
      const DeepCollectionEquality().hash(loadedMostFutureComment) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(followTimeLineMode) ^
      const DeepCollectionEquality().hash(rawUserPostedComment);

  @JsonKey(ignore: true)
  @override
  _$CommentsHolderCopyWith<_CommentsHolder> get copyWith =>
      __$CommentsHolderCopyWithImpl<_CommentsHolder>(this, _$identity);
}

abstract class _CommentsHolder extends CommentsHolder {
  const _CommentsHolder._() : super._();
  const factory _CommentsHolder(
      {@required
      @Deprecated('use [_commentSorted]')
          List<CommentItem> comments,
      @required
          String pageNationKey,
      @required
          bool loadedMostPastComment,
      @required
          bool isRenewing,
      @required
          bool loadedMostFutureComment,
      @required
          CommentsState state,
      @required
          FollowTimeLineMode followTimeLineMode,
      @required
      @Deprecated('use [userPostedComment]')
          List<CommentItem> rawUserPostedComment}) = _$_CommentsHolder;

  @override

  /// use [_commentSorted]
  @Deprecated('use [_commentSorted]')
  List<CommentItem> get comments;
  @override
  String get pageNationKey;
  @override
  bool get loadedMostPastComment;
  @override
  bool get isRenewing;
  @override
  bool get loadedMostFutureComment;
  @override
  CommentsState get state;
  @override
  FollowTimeLineMode get followTimeLineMode;
  @override

  /// use [userPostedComment]
  @Deprecated('use [userPostedComment]')
  List<CommentItem> get rawUserPostedComment;
  @override
  @JsonKey(ignore: true)
  _$CommentsHolderCopyWith<_CommentsHolder> get copyWith;
}

/// @nodoc
class _$CommentsStateTearOff {
  const _$CommentsStateTearOff();

// ignore: unused_element
  _CommentsStateSuccess success() {
    return const _CommentsStateSuccess();
  }

// ignore: unused_element
  _CommentsStateLoading loading() {
    return const _CommentsStateLoading();
  }

// ignore: unused_element
  CommentsStateLoadingMore loadingMore(LoadingState loadingState) {
    return CommentsStateLoadingMore(
      loadingState,
    );
  }

// ignore: unused_element
  _CommentsStateErr error(ErrorMsgCommon errMsg) {
    return _CommentsStateErr(
      errMsg,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $CommentsState = _$CommentsStateTearOff();

/// @nodoc
mixin _$CommentsState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult success(),
    @required TResult loading(),
    @required TResult loadingMore(LoadingState loadingState),
    @required TResult error(ErrorMsgCommon errMsg),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult success(),
    TResult loading(),
    TResult loadingMore(LoadingState loadingState),
    TResult error(ErrorMsgCommon errMsg),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult success(_CommentsStateSuccess value),
    @required TResult loading(_CommentsStateLoading value),
    @required TResult loadingMore(CommentsStateLoadingMore value),
    @required TResult error(_CommentsStateErr value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult success(_CommentsStateSuccess value),
    TResult loading(_CommentsStateLoading value),
    TResult loadingMore(CommentsStateLoadingMore value),
    TResult error(_CommentsStateErr value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $CommentsStateCopyWith<$Res> {
  factory $CommentsStateCopyWith(
          CommentsState value, $Res Function(CommentsState) then) =
      _$CommentsStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$CommentsStateCopyWithImpl<$Res>
    implements $CommentsStateCopyWith<$Res> {
  _$CommentsStateCopyWithImpl(this._value, this._then);

  final CommentsState _value;
  // ignore: unused_field
  final $Res Function(CommentsState) _then;
}

/// @nodoc
abstract class _$CommentsStateSuccessCopyWith<$Res> {
  factory _$CommentsStateSuccessCopyWith(_CommentsStateSuccess value,
          $Res Function(_CommentsStateSuccess) then) =
      __$CommentsStateSuccessCopyWithImpl<$Res>;
}

/// @nodoc
class __$CommentsStateSuccessCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res>
    implements _$CommentsStateSuccessCopyWith<$Res> {
  __$CommentsStateSuccessCopyWithImpl(
      _CommentsStateSuccess _value, $Res Function(_CommentsStateSuccess) _then)
      : super(_value, (v) => _then(v as _CommentsStateSuccess));

  @override
  _CommentsStateSuccess get _value => super._value as _CommentsStateSuccess;
}

/// @nodoc
class _$_CommentsStateSuccess extends _CommentsStateSuccess {
  const _$_CommentsStateSuccess() : super._();

  @override
  String toString() {
    return 'CommentsState.success()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CommentsStateSuccess);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult success(),
    @required TResult loading(),
    @required TResult loadingMore(LoadingState loadingState),
    @required TResult error(ErrorMsgCommon errMsg),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return success();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult success(),
    TResult loading(),
    TResult loadingMore(LoadingState loadingState),
    TResult error(ErrorMsgCommon errMsg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult success(_CommentsStateSuccess value),
    @required TResult loading(_CommentsStateLoading value),
    @required TResult loadingMore(CommentsStateLoadingMore value),
    @required TResult error(_CommentsStateErr value),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult success(_CommentsStateSuccess value),
    TResult loading(_CommentsStateLoading value),
    TResult loadingMore(CommentsStateLoadingMore value),
    TResult error(_CommentsStateErr value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _CommentsStateSuccess extends CommentsState {
  const _CommentsStateSuccess._() : super._();
  const factory _CommentsStateSuccess() = _$_CommentsStateSuccess;
}

/// @nodoc
abstract class _$CommentsStateLoadingCopyWith<$Res> {
  factory _$CommentsStateLoadingCopyWith(_CommentsStateLoading value,
          $Res Function(_CommentsStateLoading) then) =
      __$CommentsStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$CommentsStateLoadingCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res>
    implements _$CommentsStateLoadingCopyWith<$Res> {
  __$CommentsStateLoadingCopyWithImpl(
      _CommentsStateLoading _value, $Res Function(_CommentsStateLoading) _then)
      : super(_value, (v) => _then(v as _CommentsStateLoading));

  @override
  _CommentsStateLoading get _value => super._value as _CommentsStateLoading;
}

/// @nodoc
class _$_CommentsStateLoading extends _CommentsStateLoading {
  const _$_CommentsStateLoading() : super._();

  @override
  String toString() {
    return 'CommentsState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CommentsStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult success(),
    @required TResult loading(),
    @required TResult loadingMore(LoadingState loadingState),
    @required TResult error(ErrorMsgCommon errMsg),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult success(),
    TResult loading(),
    TResult loadingMore(LoadingState loadingState),
    TResult error(ErrorMsgCommon errMsg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult success(_CommentsStateSuccess value),
    @required TResult loading(_CommentsStateLoading value),
    @required TResult loadingMore(CommentsStateLoadingMore value),
    @required TResult error(_CommentsStateErr value),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult success(_CommentsStateSuccess value),
    TResult loading(_CommentsStateLoading value),
    TResult loadingMore(CommentsStateLoadingMore value),
    TResult error(_CommentsStateErr value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _CommentsStateLoading extends CommentsState {
  const _CommentsStateLoading._() : super._();
  const factory _CommentsStateLoading() = _$_CommentsStateLoading;
}

/// @nodoc
abstract class $CommentsStateLoadingMoreCopyWith<$Res> {
  factory $CommentsStateLoadingMoreCopyWith(CommentsStateLoadingMore value,
          $Res Function(CommentsStateLoadingMore) then) =
      _$CommentsStateLoadingMoreCopyWithImpl<$Res>;
  $Res call({LoadingState loadingState});

  $LoadingStateCopyWith<$Res> get loadingState;
}

/// @nodoc
class _$CommentsStateLoadingMoreCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res>
    implements $CommentsStateLoadingMoreCopyWith<$Res> {
  _$CommentsStateLoadingMoreCopyWithImpl(CommentsStateLoadingMore _value,
      $Res Function(CommentsStateLoadingMore) _then)
      : super(_value, (v) => _then(v as CommentsStateLoadingMore));

  @override
  CommentsStateLoadingMore get _value =>
      super._value as CommentsStateLoadingMore;

  @override
  $Res call({
    Object loadingState = freezed,
  }) {
    return _then(CommentsStateLoadingMore(
      loadingState == freezed
          ? _value.loadingState
          : loadingState as LoadingState,
    ));
  }

  @override
  $LoadingStateCopyWith<$Res> get loadingState {
    if (_value.loadingState == null) {
      return null;
    }
    return $LoadingStateCopyWith<$Res>(_value.loadingState, (value) {
      return _then(_value.copyWith(loadingState: value));
    });
  }
}

/// @nodoc
class _$CommentsStateLoadingMore extends CommentsStateLoadingMore {
  const _$CommentsStateLoadingMore(this.loadingState)
      : assert(loadingState != null),
        super._();

  @override
  final LoadingState loadingState;

  @override
  String toString() {
    return 'CommentsState.loadingMore(loadingState: $loadingState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CommentsStateLoadingMore &&
            (identical(other.loadingState, loadingState) ||
                const DeepCollectionEquality()
                    .equals(other.loadingState, loadingState)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(loadingState);

  @JsonKey(ignore: true)
  @override
  $CommentsStateLoadingMoreCopyWith<CommentsStateLoadingMore> get copyWith =>
      _$CommentsStateLoadingMoreCopyWithImpl<CommentsStateLoadingMore>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult success(),
    @required TResult loading(),
    @required TResult loadingMore(LoadingState loadingState),
    @required TResult error(ErrorMsgCommon errMsg),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return loadingMore(loadingState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult success(),
    TResult loading(),
    TResult loadingMore(LoadingState loadingState),
    TResult error(ErrorMsgCommon errMsg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadingMore != null) {
      return loadingMore(loadingState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult success(_CommentsStateSuccess value),
    @required TResult loading(_CommentsStateLoading value),
    @required TResult loadingMore(CommentsStateLoadingMore value),
    @required TResult error(_CommentsStateErr value),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return loadingMore(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult success(_CommentsStateSuccess value),
    TResult loading(_CommentsStateLoading value),
    TResult loadingMore(CommentsStateLoadingMore value),
    TResult error(_CommentsStateErr value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadingMore != null) {
      return loadingMore(this);
    }
    return orElse();
  }
}

abstract class CommentsStateLoadingMore extends CommentsState {
  const CommentsStateLoadingMore._() : super._();
  const factory CommentsStateLoadingMore(LoadingState loadingState) =
      _$CommentsStateLoadingMore;

  LoadingState get loadingState;
  @JsonKey(ignore: true)
  $CommentsStateLoadingMoreCopyWith<CommentsStateLoadingMore> get copyWith;
}

/// @nodoc
abstract class _$CommentsStateErrCopyWith<$Res> {
  factory _$CommentsStateErrCopyWith(
          _CommentsStateErr value, $Res Function(_CommentsStateErr) then) =
      __$CommentsStateErrCopyWithImpl<$Res>;
  $Res call({ErrorMsgCommon errMsg});

  $ErrorMsgCommonCopyWith<$Res> get errMsg;
}

/// @nodoc
class __$CommentsStateErrCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res>
    implements _$CommentsStateErrCopyWith<$Res> {
  __$CommentsStateErrCopyWithImpl(
      _CommentsStateErr _value, $Res Function(_CommentsStateErr) _then)
      : super(_value, (v) => _then(v as _CommentsStateErr));

  @override
  _CommentsStateErr get _value => super._value as _CommentsStateErr;

  @override
  $Res call({
    Object errMsg = freezed,
  }) {
    return _then(_CommentsStateErr(
      errMsg == freezed ? _value.errMsg : errMsg as ErrorMsgCommon,
    ));
  }

  @override
  $ErrorMsgCommonCopyWith<$Res> get errMsg {
    if (_value.errMsg == null) {
      return null;
    }
    return $ErrorMsgCommonCopyWith<$Res>(_value.errMsg, (value) {
      return _then(_value.copyWith(errMsg: value));
    });
  }
}

/// @nodoc
class _$_CommentsStateErr extends _CommentsStateErr {
  const _$_CommentsStateErr(this.errMsg)
      : assert(errMsg != null),
        super._();

  @override
  final ErrorMsgCommon errMsg;

  @override
  String toString() {
    return 'CommentsState.error(errMsg: $errMsg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CommentsStateErr &&
            (identical(other.errMsg, errMsg) ||
                const DeepCollectionEquality().equals(other.errMsg, errMsg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(errMsg);

  @JsonKey(ignore: true)
  @override
  _$CommentsStateErrCopyWith<_CommentsStateErr> get copyWith =>
      __$CommentsStateErrCopyWithImpl<_CommentsStateErr>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult success(),
    @required TResult loading(),
    @required TResult loadingMore(LoadingState loadingState),
    @required TResult error(ErrorMsgCommon errMsg),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return error(errMsg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult success(),
    TResult loading(),
    TResult loadingMore(LoadingState loadingState),
    TResult error(ErrorMsgCommon errMsg),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(errMsg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult success(_CommentsStateSuccess value),
    @required TResult loading(_CommentsStateLoading value),
    @required TResult loadingMore(CommentsStateLoadingMore value),
    @required TResult error(_CommentsStateErr value),
  }) {
    assert(success != null);
    assert(loading != null);
    assert(loadingMore != null);
    assert(error != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult success(_CommentsStateSuccess value),
    TResult loading(_CommentsStateLoading value),
    TResult loadingMore(CommentsStateLoadingMore value),
    TResult error(_CommentsStateErr value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _CommentsStateErr extends CommentsState {
  const _CommentsStateErr._() : super._();
  const factory _CommentsStateErr(ErrorMsgCommon errMsg) = _$_CommentsStateErr;

  ErrorMsgCommon get errMsg;
  @JsonKey(ignore: true)
  _$CommentsStateErrCopyWith<_CommentsStateErr> get copyWith;
}

/// @nodoc
class _$BtmSheetStateTearOff {
  const _$BtmSheetStateTearOff();

// ignore: unused_element
  _BtmSheetStateNone none() {
    return const _BtmSheetStateNone();
  }

// ignore: unused_element
  _BtmSheetStatePlaySpeed playSpeed() {
    return const _BtmSheetStatePlaySpeed();
  }

// ignore: unused_element
  _BtmSheetStateResolution resolution() {
    return const _BtmSheetStateResolution();
  }

// ignore: unused_element
  _BtmSheetStateShare share(ShareUrl shareUrl) {
    return _BtmSheetStateShare(
      shareUrl,
    );
  }

// ignore: unused_element
  BtmSheetStateCommentSelect commentSelect(Duration position) {
    return BtmSheetStateCommentSelect(
      position,
    );
  }

// ignore: unused_element
  _BtmSheetStatePayment payment() {
    return const _BtmSheetStatePayment();
  }
}

/// @nodoc
// ignore: unused_element
const $BtmSheetState = _$BtmSheetStateTearOff();

/// @nodoc
mixin _$BtmSheetState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $BtmSheetStateCopyWith<$Res> {
  factory $BtmSheetStateCopyWith(
          BtmSheetState value, $Res Function(BtmSheetState) then) =
      _$BtmSheetStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$BtmSheetStateCopyWithImpl<$Res>
    implements $BtmSheetStateCopyWith<$Res> {
  _$BtmSheetStateCopyWithImpl(this._value, this._then);

  final BtmSheetState _value;
  // ignore: unused_field
  final $Res Function(BtmSheetState) _then;
}

/// @nodoc
abstract class _$BtmSheetStateNoneCopyWith<$Res> {
  factory _$BtmSheetStateNoneCopyWith(
          _BtmSheetStateNone value, $Res Function(_BtmSheetStateNone) then) =
      __$BtmSheetStateNoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$BtmSheetStateNoneCopyWithImpl<$Res>
    extends _$BtmSheetStateCopyWithImpl<$Res>
    implements _$BtmSheetStateNoneCopyWith<$Res> {
  __$BtmSheetStateNoneCopyWithImpl(
      _BtmSheetStateNone _value, $Res Function(_BtmSheetStateNone) _then)
      : super(_value, (v) => _then(v as _BtmSheetStateNone));

  @override
  _BtmSheetStateNone get _value => super._value as _BtmSheetStateNone;
}

/// @nodoc
class _$_BtmSheetStateNone implements _BtmSheetStateNone {
  const _$_BtmSheetStateNone();

  @override
  String toString() {
    return 'BtmSheetState.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtmSheetStateNone);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return none();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _BtmSheetStateNone implements BtmSheetState {
  const factory _BtmSheetStateNone() = _$_BtmSheetStateNone;
}

/// @nodoc
abstract class _$BtmSheetStatePlaySpeedCopyWith<$Res> {
  factory _$BtmSheetStatePlaySpeedCopyWith(_BtmSheetStatePlaySpeed value,
          $Res Function(_BtmSheetStatePlaySpeed) then) =
      __$BtmSheetStatePlaySpeedCopyWithImpl<$Res>;
}

/// @nodoc
class __$BtmSheetStatePlaySpeedCopyWithImpl<$Res>
    extends _$BtmSheetStateCopyWithImpl<$Res>
    implements _$BtmSheetStatePlaySpeedCopyWith<$Res> {
  __$BtmSheetStatePlaySpeedCopyWithImpl(_BtmSheetStatePlaySpeed _value,
      $Res Function(_BtmSheetStatePlaySpeed) _then)
      : super(_value, (v) => _then(v as _BtmSheetStatePlaySpeed));

  @override
  _BtmSheetStatePlaySpeed get _value => super._value as _BtmSheetStatePlaySpeed;
}

/// @nodoc
class _$_BtmSheetStatePlaySpeed implements _BtmSheetStatePlaySpeed {
  const _$_BtmSheetStatePlaySpeed();

  @override
  String toString() {
    return 'BtmSheetState.playSpeed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtmSheetStatePlaySpeed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return playSpeed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (playSpeed != null) {
      return playSpeed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return playSpeed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (playSpeed != null) {
      return playSpeed(this);
    }
    return orElse();
  }
}

abstract class _BtmSheetStatePlaySpeed implements BtmSheetState {
  const factory _BtmSheetStatePlaySpeed() = _$_BtmSheetStatePlaySpeed;
}

/// @nodoc
abstract class _$BtmSheetStateResolutionCopyWith<$Res> {
  factory _$BtmSheetStateResolutionCopyWith(_BtmSheetStateResolution value,
          $Res Function(_BtmSheetStateResolution) then) =
      __$BtmSheetStateResolutionCopyWithImpl<$Res>;
}

/// @nodoc
class __$BtmSheetStateResolutionCopyWithImpl<$Res>
    extends _$BtmSheetStateCopyWithImpl<$Res>
    implements _$BtmSheetStateResolutionCopyWith<$Res> {
  __$BtmSheetStateResolutionCopyWithImpl(_BtmSheetStateResolution _value,
      $Res Function(_BtmSheetStateResolution) _then)
      : super(_value, (v) => _then(v as _BtmSheetStateResolution));

  @override
  _BtmSheetStateResolution get _value =>
      super._value as _BtmSheetStateResolution;
}

/// @nodoc
class _$_BtmSheetStateResolution implements _BtmSheetStateResolution {
  const _$_BtmSheetStateResolution();

  @override
  String toString() {
    return 'BtmSheetState.resolution()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtmSheetStateResolution);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return resolution();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (resolution != null) {
      return resolution();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return resolution(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (resolution != null) {
      return resolution(this);
    }
    return orElse();
  }
}

abstract class _BtmSheetStateResolution implements BtmSheetState {
  const factory _BtmSheetStateResolution() = _$_BtmSheetStateResolution;
}

/// @nodoc
abstract class _$BtmSheetStateShareCopyWith<$Res> {
  factory _$BtmSheetStateShareCopyWith(
          _BtmSheetStateShare value, $Res Function(_BtmSheetStateShare) then) =
      __$BtmSheetStateShareCopyWithImpl<$Res>;
  $Res call({ShareUrl shareUrl});

  $ShareUrlCopyWith<$Res> get shareUrl;
}

/// @nodoc
class __$BtmSheetStateShareCopyWithImpl<$Res>
    extends _$BtmSheetStateCopyWithImpl<$Res>
    implements _$BtmSheetStateShareCopyWith<$Res> {
  __$BtmSheetStateShareCopyWithImpl(
      _BtmSheetStateShare _value, $Res Function(_BtmSheetStateShare) _then)
      : super(_value, (v) => _then(v as _BtmSheetStateShare));

  @override
  _BtmSheetStateShare get _value => super._value as _BtmSheetStateShare;

  @override
  $Res call({
    Object shareUrl = freezed,
  }) {
    return _then(_BtmSheetStateShare(
      shareUrl == freezed ? _value.shareUrl : shareUrl as ShareUrl,
    ));
  }

  @override
  $ShareUrlCopyWith<$Res> get shareUrl {
    if (_value.shareUrl == null) {
      return null;
    }
    return $ShareUrlCopyWith<$Res>(_value.shareUrl, (value) {
      return _then(_value.copyWith(shareUrl: value));
    });
  }
}

/// @nodoc
class _$_BtmSheetStateShare implements _BtmSheetStateShare {
  const _$_BtmSheetStateShare(this.shareUrl) : assert(shareUrl != null);

  @override
  final ShareUrl shareUrl;

  @override
  String toString() {
    return 'BtmSheetState.share(shareUrl: $shareUrl)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BtmSheetStateShare &&
            (identical(other.shareUrl, shareUrl) ||
                const DeepCollectionEquality()
                    .equals(other.shareUrl, shareUrl)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(shareUrl);

  @JsonKey(ignore: true)
  @override
  _$BtmSheetStateShareCopyWith<_BtmSheetStateShare> get copyWith =>
      __$BtmSheetStateShareCopyWithImpl<_BtmSheetStateShare>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return share(shareUrl);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (share != null) {
      return share(shareUrl);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return share(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (share != null) {
      return share(this);
    }
    return orElse();
  }
}

abstract class _BtmSheetStateShare implements BtmSheetState {
  const factory _BtmSheetStateShare(ShareUrl shareUrl) = _$_BtmSheetStateShare;

  ShareUrl get shareUrl;
  @JsonKey(ignore: true)
  _$BtmSheetStateShareCopyWith<_BtmSheetStateShare> get copyWith;
}

/// @nodoc
abstract class $BtmSheetStateCommentSelectCopyWith<$Res> {
  factory $BtmSheetStateCommentSelectCopyWith(BtmSheetStateCommentSelect value,
          $Res Function(BtmSheetStateCommentSelect) then) =
      _$BtmSheetStateCommentSelectCopyWithImpl<$Res>;
  $Res call({Duration position});
}

/// @nodoc
class _$BtmSheetStateCommentSelectCopyWithImpl<$Res>
    extends _$BtmSheetStateCopyWithImpl<$Res>
    implements $BtmSheetStateCommentSelectCopyWith<$Res> {
  _$BtmSheetStateCommentSelectCopyWithImpl(BtmSheetStateCommentSelect _value,
      $Res Function(BtmSheetStateCommentSelect) _then)
      : super(_value, (v) => _then(v as BtmSheetStateCommentSelect));

  @override
  BtmSheetStateCommentSelect get _value =>
      super._value as BtmSheetStateCommentSelect;

  @override
  $Res call({
    Object position = freezed,
  }) {
    return _then(BtmSheetStateCommentSelect(
      position == freezed ? _value.position : position as Duration,
    ));
  }
}

/// @nodoc
class _$BtmSheetStateCommentSelect implements BtmSheetStateCommentSelect {
  const _$BtmSheetStateCommentSelect(this.position) : assert(position != null);

  @override
  final Duration position;

  @override
  String toString() {
    return 'BtmSheetState.commentSelect(position: $position)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BtmSheetStateCommentSelect &&
            (identical(other.position, position) ||
                const DeepCollectionEquality()
                    .equals(other.position, position)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(position);

  @JsonKey(ignore: true)
  @override
  $BtmSheetStateCommentSelectCopyWith<BtmSheetStateCommentSelect>
      get copyWith =>
          _$BtmSheetStateCommentSelectCopyWithImpl<BtmSheetStateCommentSelect>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return commentSelect(position);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (commentSelect != null) {
      return commentSelect(position);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return commentSelect(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (commentSelect != null) {
      return commentSelect(this);
    }
    return orElse();
  }
}

abstract class BtmSheetStateCommentSelect implements BtmSheetState {
  const factory BtmSheetStateCommentSelect(Duration position) =
      _$BtmSheetStateCommentSelect;

  Duration get position;
  @JsonKey(ignore: true)
  $BtmSheetStateCommentSelectCopyWith<BtmSheetStateCommentSelect> get copyWith;
}

/// @nodoc
abstract class _$BtmSheetStatePaymentCopyWith<$Res> {
  factory _$BtmSheetStatePaymentCopyWith(_BtmSheetStatePayment value,
          $Res Function(_BtmSheetStatePayment) then) =
      __$BtmSheetStatePaymentCopyWithImpl<$Res>;
}

/// @nodoc
class __$BtmSheetStatePaymentCopyWithImpl<$Res>
    extends _$BtmSheetStateCopyWithImpl<$Res>
    implements _$BtmSheetStatePaymentCopyWith<$Res> {
  __$BtmSheetStatePaymentCopyWithImpl(
      _BtmSheetStatePayment _value, $Res Function(_BtmSheetStatePayment) _then)
      : super(_value, (v) => _then(v as _BtmSheetStatePayment));

  @override
  _BtmSheetStatePayment get _value => super._value as _BtmSheetStatePayment;
}

/// @nodoc
class _$_BtmSheetStatePayment implements _BtmSheetStatePayment {
  const _$_BtmSheetStatePayment();

  @override
  String toString() {
    return 'BtmSheetState.payment()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtmSheetStatePayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult none(),
    @required TResult playSpeed(),
    @required TResult resolution(),
    @required TResult share(ShareUrl shareUrl),
    @required TResult commentSelect(Duration position),
    @required TResult payment(),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return payment();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult none(),
    TResult playSpeed(),
    TResult resolution(),
    TResult share(ShareUrl shareUrl),
    TResult commentSelect(Duration position),
    TResult payment(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (payment != null) {
      return payment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult none(_BtmSheetStateNone value),
    @required TResult playSpeed(_BtmSheetStatePlaySpeed value),
    @required TResult resolution(_BtmSheetStateResolution value),
    @required TResult share(_BtmSheetStateShare value),
    @required TResult commentSelect(BtmSheetStateCommentSelect value),
    @required TResult payment(_BtmSheetStatePayment value),
  }) {
    assert(none != null);
    assert(playSpeed != null);
    assert(resolution != null);
    assert(share != null);
    assert(commentSelect != null);
    assert(payment != null);
    return payment(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult none(_BtmSheetStateNone value),
    TResult playSpeed(_BtmSheetStatePlaySpeed value),
    TResult resolution(_BtmSheetStateResolution value),
    TResult share(_BtmSheetStateShare value),
    TResult commentSelect(BtmSheetStateCommentSelect value),
    TResult payment(_BtmSheetStatePayment value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (payment != null) {
      return payment(this);
    }
    return orElse();
  }
}

abstract class _BtmSheetStatePayment implements BtmSheetState {
  const factory _BtmSheetStatePayment() = _$_BtmSheetStatePayment;
}

/// @nodoc
class _$FollowTimeLineModeTearOff {
  const _$FollowTimeLineModeTearOff();

// ignore: unused_element
  FollowTimeLineModeNone notFollow(Duration futurePos) {
    return FollowTimeLineModeNone(
      futurePos,
    );
  }

// ignore: unused_element
  _FollowTimeLineModeFollow follow() {
    return const _FollowTimeLineModeFollow();
  }
}

/// @nodoc
// ignore: unused_element
const $FollowTimeLineMode = _$FollowTimeLineModeTearOff();

/// @nodoc
mixin _$FollowTimeLineMode {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult notFollow(Duration futurePos),
    @required TResult follow(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult notFollow(Duration futurePos),
    TResult follow(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult notFollow(FollowTimeLineModeNone value),
    @required TResult follow(_FollowTimeLineModeFollow value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult notFollow(FollowTimeLineModeNone value),
    TResult follow(_FollowTimeLineModeFollow value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $FollowTimeLineModeCopyWith<$Res> {
  factory $FollowTimeLineModeCopyWith(
          FollowTimeLineMode value, $Res Function(FollowTimeLineMode) then) =
      _$FollowTimeLineModeCopyWithImpl<$Res>;
}

/// @nodoc
class _$FollowTimeLineModeCopyWithImpl<$Res>
    implements $FollowTimeLineModeCopyWith<$Res> {
  _$FollowTimeLineModeCopyWithImpl(this._value, this._then);

  final FollowTimeLineMode _value;
  // ignore: unused_field
  final $Res Function(FollowTimeLineMode) _then;
}

/// @nodoc
abstract class $FollowTimeLineModeNoneCopyWith<$Res> {
  factory $FollowTimeLineModeNoneCopyWith(FollowTimeLineModeNone value,
          $Res Function(FollowTimeLineModeNone) then) =
      _$FollowTimeLineModeNoneCopyWithImpl<$Res>;
  $Res call({Duration futurePos});
}

/// @nodoc
class _$FollowTimeLineModeNoneCopyWithImpl<$Res>
    extends _$FollowTimeLineModeCopyWithImpl<$Res>
    implements $FollowTimeLineModeNoneCopyWith<$Res> {
  _$FollowTimeLineModeNoneCopyWithImpl(FollowTimeLineModeNone _value,
      $Res Function(FollowTimeLineModeNone) _then)
      : super(_value, (v) => _then(v as FollowTimeLineModeNone));

  @override
  FollowTimeLineModeNone get _value => super._value as FollowTimeLineModeNone;

  @override
  $Res call({
    Object futurePos = freezed,
  }) {
    return _then(FollowTimeLineModeNone(
      futurePos == freezed ? _value.futurePos : futurePos as Duration,
    ));
  }
}

/// @nodoc
class _$FollowTimeLineModeNone implements FollowTimeLineModeNone {
  const _$FollowTimeLineModeNone(this.futurePos) : assert(futurePos != null);

  @override
  final Duration futurePos;

  @override
  String toString() {
    return 'FollowTimeLineMode.notFollow(futurePos: $futurePos)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FollowTimeLineModeNone &&
            (identical(other.futurePos, futurePos) ||
                const DeepCollectionEquality()
                    .equals(other.futurePos, futurePos)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(futurePos);

  @JsonKey(ignore: true)
  @override
  $FollowTimeLineModeNoneCopyWith<FollowTimeLineModeNone> get copyWith =>
      _$FollowTimeLineModeNoneCopyWithImpl<FollowTimeLineModeNone>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult notFollow(Duration futurePos),
    @required TResult follow(),
  }) {
    assert(notFollow != null);
    assert(follow != null);
    return notFollow(futurePos);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult notFollow(Duration futurePos),
    TResult follow(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notFollow != null) {
      return notFollow(futurePos);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult notFollow(FollowTimeLineModeNone value),
    @required TResult follow(_FollowTimeLineModeFollow value),
  }) {
    assert(notFollow != null);
    assert(follow != null);
    return notFollow(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult notFollow(FollowTimeLineModeNone value),
    TResult follow(_FollowTimeLineModeFollow value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notFollow != null) {
      return notFollow(this);
    }
    return orElse();
  }
}

abstract class FollowTimeLineModeNone implements FollowTimeLineMode {
  const factory FollowTimeLineModeNone(Duration futurePos) =
      _$FollowTimeLineModeNone;

  Duration get futurePos;
  @JsonKey(ignore: true)
  $FollowTimeLineModeNoneCopyWith<FollowTimeLineModeNone> get copyWith;
}

/// @nodoc
abstract class _$FollowTimeLineModeFollowCopyWith<$Res> {
  factory _$FollowTimeLineModeFollowCopyWith(_FollowTimeLineModeFollow value,
          $Res Function(_FollowTimeLineModeFollow) then) =
      __$FollowTimeLineModeFollowCopyWithImpl<$Res>;
}

/// @nodoc
class __$FollowTimeLineModeFollowCopyWithImpl<$Res>
    extends _$FollowTimeLineModeCopyWithImpl<$Res>
    implements _$FollowTimeLineModeFollowCopyWith<$Res> {
  __$FollowTimeLineModeFollowCopyWithImpl(_FollowTimeLineModeFollow _value,
      $Res Function(_FollowTimeLineModeFollow) _then)
      : super(_value, (v) => _then(v as _FollowTimeLineModeFollow));

  @override
  _FollowTimeLineModeFollow get _value =>
      super._value as _FollowTimeLineModeFollow;
}

/// @nodoc
class _$_FollowTimeLineModeFollow implements _FollowTimeLineModeFollow {
  const _$_FollowTimeLineModeFollow();

  @override
  String toString() {
    return 'FollowTimeLineMode.follow()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FollowTimeLineModeFollow);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult notFollow(Duration futurePos),
    @required TResult follow(),
  }) {
    assert(notFollow != null);
    assert(follow != null);
    return follow();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult notFollow(Duration futurePos),
    TResult follow(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (follow != null) {
      return follow();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult notFollow(FollowTimeLineModeNone value),
    @required TResult follow(_FollowTimeLineModeFollow value),
  }) {
    assert(notFollow != null);
    assert(follow != null);
    return follow(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult notFollow(FollowTimeLineModeNone value),
    TResult follow(_FollowTimeLineModeFollow value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (follow != null) {
      return follow(this);
    }
    return orElse();
  }
}

abstract class _FollowTimeLineModeFollow implements FollowTimeLineMode {
  const factory _FollowTimeLineModeFollow() = _$_FollowTimeLineModeFollow;
}

/// @nodoc
class _$ShareUrlTearOff {
  const _$ShareUrlTearOff();

// ignore: unused_element
  _ShareUrl call(
      {@required String urlTwitter,
      @required String urlFaceBook,
      @required String url}) {
    return _ShareUrl(
      urlTwitter: urlTwitter,
      urlFaceBook: urlFaceBook,
      url: url,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ShareUrl = _$ShareUrlTearOff();

/// @nodoc
mixin _$ShareUrl {
  String get urlTwitter;
  String get urlFaceBook;
  String get url;

  @JsonKey(ignore: true)
  $ShareUrlCopyWith<ShareUrl> get copyWith;
}

/// @nodoc
abstract class $ShareUrlCopyWith<$Res> {
  factory $ShareUrlCopyWith(ShareUrl value, $Res Function(ShareUrl) then) =
      _$ShareUrlCopyWithImpl<$Res>;
  $Res call({String urlTwitter, String urlFaceBook, String url});
}

/// @nodoc
class _$ShareUrlCopyWithImpl<$Res> implements $ShareUrlCopyWith<$Res> {
  _$ShareUrlCopyWithImpl(this._value, this._then);

  final ShareUrl _value;
  // ignore: unused_field
  final $Res Function(ShareUrl) _then;

  @override
  $Res call({
    Object urlTwitter = freezed,
    Object urlFaceBook = freezed,
    Object url = freezed,
  }) {
    return _then(_value.copyWith(
      urlTwitter:
          urlTwitter == freezed ? _value.urlTwitter : urlTwitter as String,
      urlFaceBook:
          urlFaceBook == freezed ? _value.urlFaceBook : urlFaceBook as String,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

/// @nodoc
abstract class _$ShareUrlCopyWith<$Res> implements $ShareUrlCopyWith<$Res> {
  factory _$ShareUrlCopyWith(_ShareUrl value, $Res Function(_ShareUrl) then) =
      __$ShareUrlCopyWithImpl<$Res>;
  @override
  $Res call({String urlTwitter, String urlFaceBook, String url});
}

/// @nodoc
class __$ShareUrlCopyWithImpl<$Res> extends _$ShareUrlCopyWithImpl<$Res>
    implements _$ShareUrlCopyWith<$Res> {
  __$ShareUrlCopyWithImpl(_ShareUrl _value, $Res Function(_ShareUrl) _then)
      : super(_value, (v) => _then(v as _ShareUrl));

  @override
  _ShareUrl get _value => super._value as _ShareUrl;

  @override
  $Res call({
    Object urlTwitter = freezed,
    Object urlFaceBook = freezed,
    Object url = freezed,
  }) {
    return _then(_ShareUrl(
      urlTwitter:
          urlTwitter == freezed ? _value.urlTwitter : urlTwitter as String,
      urlFaceBook:
          urlFaceBook == freezed ? _value.urlFaceBook : urlFaceBook as String,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

/// @nodoc
class _$_ShareUrl implements _ShareUrl {
  const _$_ShareUrl(
      {@required this.urlTwitter,
      @required this.urlFaceBook,
      @required this.url})
      : assert(urlTwitter != null),
        assert(urlFaceBook != null),
        assert(url != null);

  @override
  final String urlTwitter;
  @override
  final String urlFaceBook;
  @override
  final String url;

  @override
  String toString() {
    return 'ShareUrl(urlTwitter: $urlTwitter, urlFaceBook: $urlFaceBook, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ShareUrl &&
            (identical(other.urlTwitter, urlTwitter) ||
                const DeepCollectionEquality()
                    .equals(other.urlTwitter, urlTwitter)) &&
            (identical(other.urlFaceBook, urlFaceBook) ||
                const DeepCollectionEquality()
                    .equals(other.urlFaceBook, urlFaceBook)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(urlTwitter) ^
      const DeepCollectionEquality().hash(urlFaceBook) ^
      const DeepCollectionEquality().hash(url);

  @JsonKey(ignore: true)
  @override
  _$ShareUrlCopyWith<_ShareUrl> get copyWith =>
      __$ShareUrlCopyWithImpl<_ShareUrl>(this, _$identity);
}

abstract class _ShareUrl implements ShareUrl {
  const factory _ShareUrl(
      {@required String urlTwitter,
      @required String urlFaceBook,
      @required String url}) = _$_ShareUrl;

  @override
  String get urlTwitter;
  @override
  String get urlFaceBook;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$ShareUrlCopyWith<_ShareUrl> get copyWith;
}

/// @nodoc
class _$LoadingStateTearOff {
  const _$LoadingStateTearOff();

// ignore: unused_element
  _Feature feature() {
    return const _Feature();
  }

// ignore: unused_element
  _Past past() {
    return const _Past();
  }
}

/// @nodoc
// ignore: unused_element
const $LoadingState = _$LoadingStateTearOff();

/// @nodoc
mixin _$LoadingState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult feature(),
    @required TResult past(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult feature(),
    TResult past(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult feature(_Feature value),
    @required TResult past(_Past value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult feature(_Feature value),
    TResult past(_Past value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $LoadingStateCopyWith<$Res> {
  factory $LoadingStateCopyWith(
          LoadingState value, $Res Function(LoadingState) then) =
      _$LoadingStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoadingStateCopyWithImpl<$Res> implements $LoadingStateCopyWith<$Res> {
  _$LoadingStateCopyWithImpl(this._value, this._then);

  final LoadingState _value;
  // ignore: unused_field
  final $Res Function(LoadingState) _then;
}

/// @nodoc
abstract class _$FeatureCopyWith<$Res> {
  factory _$FeatureCopyWith(_Feature value, $Res Function(_Feature) then) =
      __$FeatureCopyWithImpl<$Res>;
}

/// @nodoc
class __$FeatureCopyWithImpl<$Res> extends _$LoadingStateCopyWithImpl<$Res>
    implements _$FeatureCopyWith<$Res> {
  __$FeatureCopyWithImpl(_Feature _value, $Res Function(_Feature) _then)
      : super(_value, (v) => _then(v as _Feature));

  @override
  _Feature get _value => super._value as _Feature;
}

/// @nodoc
class _$_Feature implements _Feature {
  const _$_Feature();

  @override
  String toString() {
    return 'LoadingState.feature()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Feature);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult feature(),
    @required TResult past(),
  }) {
    assert(feature != null);
    assert(past != null);
    return feature();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult feature(),
    TResult past(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (feature != null) {
      return feature();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult feature(_Feature value),
    @required TResult past(_Past value),
  }) {
    assert(feature != null);
    assert(past != null);
    return feature(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult feature(_Feature value),
    TResult past(_Past value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (feature != null) {
      return feature(this);
    }
    return orElse();
  }
}

abstract class _Feature implements LoadingState {
  const factory _Feature() = _$_Feature;
}

/// @nodoc
abstract class _$PastCopyWith<$Res> {
  factory _$PastCopyWith(_Past value, $Res Function(_Past) then) =
      __$PastCopyWithImpl<$Res>;
}

/// @nodoc
class __$PastCopyWithImpl<$Res> extends _$LoadingStateCopyWithImpl<$Res>
    implements _$PastCopyWith<$Res> {
  __$PastCopyWithImpl(_Past _value, $Res Function(_Past) _then)
      : super(_value, (v) => _then(v as _Past));

  @override
  _Past get _value => super._value as _Past;
}

/// @nodoc
class _$_Past implements _Past {
  const _$_Past();

  @override
  String toString() {
    return 'LoadingState.past()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Past);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult feature(),
    @required TResult past(),
  }) {
    assert(feature != null);
    assert(past != null);
    return past();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult feature(),
    TResult past(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (past != null) {
      return past();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult feature(_Feature value),
    @required TResult past(_Past value),
  }) {
    assert(feature != null);
    assert(past != null);
    return past(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult feature(_Feature value),
    TResult past(_Past value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (past != null) {
      return past(this);
    }
    return orElse();
  }
}

abstract class _Past implements LoadingState {
  const factory _Past() = _$_Past;
}
